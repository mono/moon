/*
 * Automatically generated, do not edit this file directly
 */


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "animation.h"
#include "application.h"
#include "bitmapimage.h"
#include "bitmapsource.h"
#include "border.h"
#include "brush.h"
#include "canvas.h"
#include "collection.h"
#include "color.h"
#include "contentcontrol.h"
#include "control.h"
#include "deepzoomimagetilesource.h"
#include "dependencyobject.h"
#include "dependencyproperty.h"
#include "deployment.h"
#include "downloader.h"
#include "easing.h"
#include "frameworkelement.h"
#include "geometry.h"
#include "glyphs.h"
#include "grid.h"
#include "media.h"
#include "mediaelement.h"
#include "multiscaleimage.h"
#include "multiscalesubimage.h"
#include "namescope.h"
#include "panel.h"
#include "popup.h"
#include "provider.h"
#include "shape.h"
#include "style.h"
#include "stylus.h"
#include "template.h"
#include "textblock.h"
#include "textbox.h"
#include "timeline.h"
#include "transform.h"
#include "trigger.h"
#include "uielement.h"
#include "usercontrol.h"
#include "validators.h"

void
Types::RegisterNativeProperties ()
{
	DependencyProperty::Register (this, Type::VISUALBRUSH, "Visual", Type::UIELEMENT);
	DependencyProperty::Register (this, Type::VIDEOBRUSH, "SourceName", new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::IMAGEBRUSH, "ImageSource", Type::IMAGESOURCE);
	DependencyProperty::Register (this, Type::IMAGEBRUSH, "DownloadProgress", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RADIALGRADIENTBRUSH, "RadiusY", new Value (0.5), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RADIALGRADIENTBRUSH, "RadiusX", new Value (0.5), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RADIALGRADIENTBRUSH, "GradientOrigin", new Value (Point (0.5, 0.5)), Type::POINT);
	DependencyProperty::Register (this, Type::RADIALGRADIENTBRUSH, "Center", new Value (Point (0.5, 0.5)), Type::POINT);
	DependencyProperty::Register (this, Type::LINEARGRADIENTBRUSH, "StartPoint", Type::POINT);
	DependencyProperty::Register (this, Type::LINEARGRADIENTBRUSH, "EndPoint", new Value (Point(1,1)), Type::POINT);
	DependencyProperty::Register (this, Type::SOLIDCOLORBRUSH, "Color", new Value (Color (0x00000000)), Type::COLOR);
	DependencyProperty::Register (this, Type::TILEBRUSH, "Stretch", new Value (StretchFill), Type::INT32);
	DependencyProperty::Register (this, Type::TILEBRUSH, "AlignmentY", new Value (AlignmentYCenter), Type::INT32);
	DependencyProperty::Register (this, Type::TILEBRUSH, "AlignmentX", new Value (AlignmentXCenter), Type::INT32);
	DependencyProperty::Register (this, Type::GRADIENTBRUSH, "SpreadMethod", new Value (GradientSpreadMethodPad), Type::INT32);
	DependencyProperty::Register (this, Type::GRADIENTBRUSH, "MappingMode", new Value (BrushMappingModeRelativeToBoundingBox), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::GRADIENTBRUSH, "GradientStops", NULL, Type::GRADIENTSTOP_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::GRADIENTBRUSH, "ColorInterpolationMode", new Value (ColorInterpolationModeSRgbLinearInterpolation), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::INKPRESENTER, "Strokes", NULL, Type::STROKE_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::BRUSH, "Transform", new Value (new MatrixTransform ()), Type::TRANSFORM);
	DependencyProperty::Register (this, Type::BRUSH, "RelativeTransform", new Value (new MatrixTransform ()), Type::TRANSFORM);
	DependencyProperty::Register (this, Type::BRUSH, "Opacity", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::BRUSH, "Changed", Type::BOOL);
	DependencyProperty::Register (this, Type::RECTANGLE, "RadiusY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RECTANGLE, "RadiusX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::POLYLINE, "Points", NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::POLYLINE, "FillRule", new Value (FillRuleEvenOdd), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::POLYGON, "Points", NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::POLYGON, "FillRule", new Value (FillRuleEvenOdd), Type::INT32);
	DependencyProperty::Register (this, Type::PATH, "Data", Type::GEOMETRY);
	DependencyProperty::Register (this, Type::LINE, "Y2", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::LINE, "Y1", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::LINE, "X2", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::LINE, "X1", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "ViewportWidth", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "ViewportOrigin", new Value (Point(0,0)), Type::POINT);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "UseSprings", new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "TileFade", new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::MULTISCALEIMAGE, "SubImages", NULL, Type::MULTISCALESUBIMAGE_COLLECTION, false, true, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "Source", Type::MULTISCALETILESOURCE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "IsIdle", new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "IsDownloading", new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "BlurFactor", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "AspectRatio", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALEIMAGE, "AllowDownloading", new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::IMAGE, "Source", NULL, Type::IMAGESOURCE, false, false, false, NULL, NULL, Image::CreateDefaultImageSource, false, false);
	DependencyProperty::Register (this, Type::USERCONTROL, "Content", Type::UIELEMENT);
	DependencyProperty::Register (this, Type::CONTENTCONTROL, "ContentTemplate", Type::DATATEMPLATE);
	DependencyProperty::RegisterFull (this, Type::CONTENTCONTROL, "Content", NULL, Type::OBJECT, false, false, false, NULL, Validators::ContentControlContentValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::GRID, "ShowGridLines", new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::GRID, "RowSpan", new Value (1), Type::INT32, true, false, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "Row", new Value (0), Type::INT32, true, false, false, NULL, Validators::PositiveIntValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "RowDefinitions", NULL, Type::ROWDEFINITION_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "ColumnSpan", new Value (1), Type::INT32, true, false, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "Column", new Value (0), Type::INT32, true, false, false, NULL, Validators::PositiveIntValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::GRID, "ColumnDefinitions", NULL, Type::COLUMNDEFINITION_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::RegisterFull (this, Type::CANVAS, "ZIndex", new Value (0), Type::INT32, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::CANVAS, "Top", new Value (0.0), Type::DOUBLE, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::CANVAS, "Left", new Value (0.0), Type::DOUBLE, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "TextWrapping", new Value (TextWrappingNoWrap), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "Text", new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "TextDecorations", new Value (TextDecorationsNone), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "TextAlignment", new Value (TextAlignmentLeft), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "Padding", new Value (Thickness (0)), Type::THICKNESS);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "LineStackingStrategy", new Value (LineStackingStrategyMaxHeight), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "LineHeight", new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::TEXTBLOCK, "Inlines", NULL, Type::INLINE_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "Foreground", new Value (new SolidColorBrush("black")), Type::BRUSH);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontWeight", new Value (TEXTBLOCK_FONT_WEIGHT), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontStyle", new Value (TEXTBLOCK_FONT_STYLE), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontStretch", new Value (TEXTBLOCK_FONT_STRETCH), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontSource", Type::FONTSOURCE);
	DependencyProperty::RegisterFull (this, Type::TEXTBLOCK, "FontSize", NULL, Type::DOUBLE, false, false, false, NULL, NULL, AutoCreators::CreateDefaultFontSize, false, false);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontGUID", Type::STRING);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontFilename", Type::STRING);
	DependencyProperty::Register (this, Type::TEXTBLOCK, "FontFamily", new Value (FontFamily(TEXTBLOCK_FONT_FAMILY)), Type::FONTFAMILY);
	DependencyProperty::Register (this, Type::POPUP, "VerticalOffset", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::POPUP, "IsOpen", new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::POPUP, "HorizontalOffset", new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::POPUP, "Child", NULL, Type::UIELEMENT, false, false, false, NULL, Validators::ContentControlContentValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "Volume", new Value (0.5), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "Stretch", new Value (StretchUniform), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Source", NULL, Type::URI, false, false, true, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "RenderedFramesPerSecond", new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Position", NULL, Type::TIMESPAN, false, false, true, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "NaturalVideoWidth", new Value (0), Type::INT32, false, true, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "NaturalVideoHeight", new Value (0), Type::INT32, false, true, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "NaturalDuration", new Value (Duration::FromSeconds (0)), Type::DURATION, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Markers", NULL, Type::TIMELINEMARKER_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "IsMuted", new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "DroppedFramesPerSecond", new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "DownloadProgress", new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "DownloadProgressOffset", new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "CurrentState", new Value (MediaStateClosed), Type::INT32, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "CanSeek", new Value (false), Type::BOOL, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "CanPause", new Value (false), Type::BOOL, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "BufferingTime", NULL, Type::TIMESPAN, false, false, false, NULL, Validators::BufferingTimeValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "BufferingProgress", new Value (0.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "Balance", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MEDIAELEMENT, "AutoPlay", new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "AudioStreamIndex", NULL, Type::INT32, false, false, false, NULL, Validators::AudioStreamIndexValidator, NULL, false, true);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "AudioStreamCount", new Value (0), Type::INT32, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::MEDIAELEMENT, "Attributes", NULL, Type::MEDIAATTRIBUTE_COLLECTION, false, false, false, NULL, Validators::MediaAttributeCollectionValidator, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeThickness", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeStartLineCap", new Value (PenLineCapFlat), Type::INT32);
	DependencyProperty::Register (this, Type::SHAPE, "Stroke", Type::BRUSH);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeMiterLimit", new Value (10.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeLineJoin", new Value (PenLineJoinMiter), Type::INT32);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeEndLineCap", new Value (PenLineCapFlat), Type::INT32);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeDashOffset", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeDashCap", new Value (PenLineCapFlat), Type::INT32);
	DependencyProperty::Register (this, Type::SHAPE, "StrokeDashArray", Type::DOUBLE_COLLECTION);
	DependencyProperty::RegisterFull (this, Type::SHAPE, "Stretch", NULL, Type::INT32, false, false, false, NULL, NULL, Shape::CreateDefaultStretch, false, false);
	DependencyProperty::Register (this, Type::SHAPE, "Fill", Type::BRUSH);
	DependencyProperty::Register (this, Type::MEDIABASE, "Stretch", new Value (StretchUniform), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::MEDIABASE, "Source", NULL, Type::STRING, false, false, true, NULL, NULL, NULL, false, false);
	DependencyProperty::Register (this, Type::MEDIABASE, "DownloadProgress", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GLYPHS, "UnicodeString", new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::GLYPHS, "StyleSimulations", new Value (StyleSimulationsNone), Type::INT32);
	DependencyProperty::Register (this, Type::GLYPHS, "OriginY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GLYPHS, "OriginX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GLYPHS, "Indices", new Value (""), Type::STRING);
	DependencyProperty::RegisterFull (this, Type::GLYPHS, "FontUri", new Value (Uri()), Type::URI, false, false, false, NULL, Validators::NonNullValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::GLYPHS, "FontRenderingEmSize", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GLYPHS, "Fill", Type::BRUSH);
	DependencyProperty::Register (this, Type::CONTROL, "VerticalContentAlignment", new Value (VerticalAlignmentCenter), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::CONTROL, "Template", NULL, Type::CONTROLTEMPLATE, false, false, false, NULL, Validators::TemplateValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::CONTROL, "TabNavigation", new Value (KeyboardNavigationModeLocal), Type::INT32);
	DependencyProperty::Register (this, Type::CONTROL, "TabIndex", new Value (INT_MAX), Type::INT32);
	DependencyProperty::Register (this, Type::CONTROL, "Padding", new Value (Thickness(0.0)), Type::THICKNESS);
	DependencyProperty::Register (this, Type::CONTROL, "IsTabStop", new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::CONTROL, "HorizontalContentAlignment", new Value (HorizontalAlignmentCenter), Type::INT32);
	DependencyProperty::Register (this, Type::CONTROL, "Foreground", new Value (new SolidColorBrush("black")), Type::BRUSH);
	DependencyProperty::Register (this, Type::CONTROL, "FontWeight", new Value (CONTROL_FONT_WEIGHT), Type::INT32);
	DependencyProperty::Register (this, Type::CONTROL, "FontStyle", new Value (CONTROL_FONT_STYLE), Type::INT32);
	DependencyProperty::Register (this, Type::CONTROL, "FontStretch", new Value (CONTROL_FONT_STRETCH), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::CONTROL, "FontSize", NULL, Type::DOUBLE, false, false, false, NULL, NULL, AutoCreators::CreateDefaultFontSize, false, false);
	DependencyProperty::Register (this, Type::CONTROL, "FontFamily", new Value (FontFamily(CONTROL_FONT_FAMILY)), Type::FONTFAMILY);
	DependencyProperty::Register (this, Type::CONTROL, "DefaultStyleKey", Type::MANAGEDTYPEINFO);
	DependencyProperty::Register (this, Type::CONTROL, "BorderThickness", new Value (Thickness(0.0)), Type::THICKNESS);
	DependencyProperty::Register (this, Type::CONTROL, "BorderBrush", Type::BRUSH);
	DependencyProperty::Register (this, Type::CONTROL, "Background", Type::BRUSH);
	DependencyProperty::RegisterFull (this, Type::PANEL, "Children", NULL, Type::UIELEMENT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::PANEL, "Background", Type::BRUSH);
	DependencyProperty::RegisterFull (this, Type::BORDER, "Padding", new Value (Thickness(0)), Type::THICKNESS, false, false, false, NULL, Validators::BorderThicknessValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::BORDER, "CornerRadius", NULL, Type::CORNERRADIUS, false, false, false, NULL, Validators::CornerRadiusValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::BORDER, "Child", Type::UIELEMENT);
	DependencyProperty::RegisterFull (this, Type::BORDER, "BorderThickness", new Value (Thickness(0)), Type::THICKNESS, false, false, false, NULL, Validators::BorderThicknessValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::BORDER, "BorderBrush", Type::BRUSH);
	DependencyProperty::Register (this, Type::BORDER, "Background", Type::BRUSH);
	DependencyProperty::RegisterFull (this, Type::TIMELINEGROUP, "Children", NULL, Type::TIMELINE_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::RegisterFull (this, Type::SETTER, "Value", NULL, Type::OBJECT, false, false, false, NULL, Validators::IsSetterSealedValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::SETTER, "Property", NULL, Type::DEPENDENCYPROPERTY, false, false, false, NULL, Validators::IsSetterSealedValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::SETTER, "ConvertedValue", Type::OBJECT);
	DependencyProperty::Register (this, Type::RUN, "Text", Type::STRING);
	DependencyProperty::Register (this, Type::RECTANGLEGEOMETRY, "Rect", Type::RECT);
	DependencyProperty::Register (this, Type::RECTANGLEGEOMETRY, "RadiusY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::RECTANGLEGEOMETRY, "RadiusX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::PATHGEOMETRY, "FillRule", new Value (FillRuleEvenOdd), Type::INT32);
	DependencyProperty::Register (this, Type::PATHGEOMETRY, "Figures", Type::PATHFIGURE_COLLECTION);
	DependencyProperty::Register (this, Type::LINEGEOMETRY, "StartPoint", Type::POINT);
	DependencyProperty::Register (this, Type::LINEGEOMETRY, "EndPoint", Type::POINT);
	DependencyProperty::Register (this, Type::GEOMETRYGROUP, "FillRule", new Value (FillRuleEvenOdd), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::GEOMETRYGROUP, "Children", NULL, Type::GEOMETRY_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::ELLIPSEGEOMETRY, "RadiusY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ELLIPSEGEOMETRY, "RadiusX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ELLIPSEGEOMETRY, "Center", Type::POINT);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "Width", new Value (NAN), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "VerticalAlignment", new Value (VerticalAlignmentStretch), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::FRAMEWORKELEMENT, "Style", NULL, Type::STYLE, false, false, false, NULL, Validators::StyleValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "MinWidth", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "MinHeight", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "MaxWidth", new Value (INFINITY), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "MaxHeight", new Value (INFINITY), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "Margin", new Value (Thickness (0)), Type::THICKNESS);
	DependencyProperty::RegisterFull (this, Type::FRAMEWORKELEMENT, "Language", new Value ("en-US"), Type::STRING, false, false, false, NULL, Validators::NonNullValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "HorizontalAlignment", new Value (HorizontalAlignmentStretch), Type::INT32);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "Height", new Value (NAN), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "DataContext", Type::OBJECT);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "ActualWidth", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::FRAMEWORKELEMENT, "ActualHeight", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::POWEREASE, "Power", new Value (2.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::EXPONENTIALEASE, "Exponent", new Value (2.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ELASTICEASE, "Springiness", new Value (3.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ELASTICEASE, "Oscillations", new Value (3), Type::INT32);
	DependencyProperty::Register (this, Type::BOUNCEEASE, "Bounciness", new Value (2.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::BOUNCEEASE, "Bounces", new Value (3), Type::INT32);
	DependencyProperty::Register (this, Type::BACKEASE, "Amplitude", new Value (1.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::SPLINEPOINTKEYFRAME, "KeySpline", NULL, Type::KEYSPLINE, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::EASINGPOINTKEYFRAME, "EasingFunction", Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::POINTANIMATIONUSINGKEYFRAMES, "KeyFrames", NULL, Type::POINTKEYFRAME_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::RegisterFull (this, Type::SPLINEDOUBLEKEYFRAME, "KeySpline", NULL, Type::KEYSPLINE, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::EASINGDOUBLEKEYFRAME, "EasingFunction", Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::DOUBLEANIMATIONUSINGKEYFRAMES, "KeyFrames", NULL, Type::DOUBLEKEYFRAME_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::TIMELINEMARKER, "Type", Type::STRING);
	DependencyProperty::Register (this, Type::TIMELINEMARKER, "Time", Type::TIMESPAN);
	DependencyProperty::Register (this, Type::TIMELINEMARKER, "Text", Type::STRING);
	DependencyProperty::Register (this, Type::TIMELINE, "SpeedRatio", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::TIMELINE, "RepeatBehavior", new Value (RepeatBehavior ((double) 1)), Type::REPEATBEHAVIOR);
	DependencyProperty::Register (this, Type::TIMELINE, "FillBehavior", new Value (FillBehaviorHoldEnd), Type::INT32);
	DependencyProperty::Register (this, Type::TIMELINE, "Duration", new Value (Duration::Automatic), Type::DURATION);
	DependencyProperty::Register (this, Type::TIMELINE, "BeginTime", new Value (0,Type::TIMESPAN), Type::TIMESPAN);
	DependencyProperty::Register (this, Type::TIMELINE, "AutoReverse", new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::STYLUSPOINT, "Y", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::STYLUSPOINT, "X", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::STYLUSPOINT, "PressureFactor", new Value (0.5), Type::DOUBLE);
	DependencyProperty::Register (this, Type::STYLUSINFO, "IsInverted", new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::STYLUSINFO, "DeviceType", new Value (TabletDeviceTypeMouse), Type::INT32);
	DependencyProperty::Register (this, Type::STYLE, "TargetType", Type::MANAGEDTYPEINFO);
	DependencyProperty::RegisterFull (this, Type::STYLE, "Setters", NULL, Type::SETTERBASE_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::STYLE, "IsSealed", new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::STROKE, "StylusPoints", NULL, Type::STYLUSPOINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::RegisterFull (this, Type::STROKE, "DrawingAttributes", NULL, Type::DRAWINGATTRIBUTES, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::SETTERBASE, "IsSealed", new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::ROWDEFINITION, "MinHeight", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROWDEFINITION, "MaxHeight", new Value (INFINITY), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROWDEFINITION, "Height", new Value (GridLength (1.0, GridUnitTypeStar)), Type::GRIDLENGTH);
	DependencyProperty::Register (this, Type::PATHFIGURE, "StartPoint", Type::POINT);
	DependencyProperty::RegisterFull (this, Type::PATHFIGURE, "Segments", NULL, Type::PATHSEGMENT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::PATHFIGURE, "IsFilled", new Value (true), Type::BOOL);
	DependencyProperty::Register (this, Type::PATHFIGURE, "IsClosed", new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::NAMESCOPE, "NameScope", NULL, Type::NAMESCOPE, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::Register (this, Type::MULTISCALESUBIMAGE, "ZIndex", new Value (0), Type::INT32);
	DependencyProperty::Register (this, Type::MULTISCALESUBIMAGE, "ViewportWidth", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MULTISCALESUBIMAGE, "ViewportOrigin", new Value (Point(0,0)), Type::POINT);
	DependencyProperty::Register (this, Type::MULTISCALESUBIMAGE, "Opacity", new Value (1.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::MULTISCALESUBIMAGE, "AspectRatio", new Value (1.0), Type::DOUBLE, false, true, false, NULL, NULL, NULL, false, false);
	DependencyProperty::Register (this, Type::MEDIAATTRIBUTE, "Value", Type::STRING);
	DependencyProperty::Register (this, Type::MATRIX, "OffsetY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "OffsetX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "M22", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "M21", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "M12", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::MATRIX, "M11", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::KEYSPLINE, "ControlPoint2", new Value (Point (1.0, 1.0)), Type::POINT);
	DependencyProperty::Register (this, Type::KEYSPLINE, "ControlPoint1", new Value (Point (0,0)), Type::POINT);
	DependencyProperty::RegisterFull (this, Type::INPUTMETHOD, "IsInputMethodEnabled", NULL, Type::BOOL, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::Register (this, Type::INLINE, "TextDecorations", new Value (TextDecorationsNone), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::INLINE, "Language", new Value ("en-US"), Type::STRING, false, false, false, NULL, Validators::NonNullValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::INLINE, "Foreground", new Value (new SolidColorBrush("black")), Type::BRUSH);
	DependencyProperty::Register (this, Type::INLINE, "FontWeight", new Value (TEXTBLOCK_FONT_WEIGHT), Type::INT32);
	DependencyProperty::Register (this, Type::INLINE, "FontStyle", new Value (TEXTBLOCK_FONT_STYLE), Type::INT32);
	DependencyProperty::Register (this, Type::INLINE, "FontStretch", new Value (TEXTBLOCK_FONT_STRETCH), Type::INT32);
	DependencyProperty::Register (this, Type::INLINE, "FontSource", Type::FONTSOURCE);
	DependencyProperty::RegisterFull (this, Type::INLINE, "FontSize", NULL, Type::DOUBLE, false, false, false, NULL, NULL, AutoCreators::CreateDefaultFontSize, false, false);
	DependencyProperty::Register (this, Type::INLINE, "FontGUID", Type::STRING);
	DependencyProperty::Register (this, Type::INLINE, "FontFilename", Type::STRING);
	DependencyProperty::Register (this, Type::INLINE, "FontFamily", new Value (FontFamily(TEXTBLOCK_FONT_FAMILY)), Type::FONTFAMILY);
	DependencyProperty::Register (this, Type::GRADIENTSTOP, "Offset", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::GRADIENTSTOP, "Color", new Value (Color (0x00000000)), Type::COLOR);
	DependencyProperty::Register (this, Type::GEOMETRY, "Transform", Type::TRANSFORM);
	DependencyProperty::Register (this, Type::DRAWINGATTRIBUTES, "Width", new Value (3.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::DRAWINGATTRIBUTES, "OutlineColor", new Value (Color (0x00000000)), Type::COLOR);
	DependencyProperty::Register (this, Type::DRAWINGATTRIBUTES, "Height", new Value (3.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::DRAWINGATTRIBUTES, "Color", new Value (Color (0xFF000000)), Type::COLOR);
	DependencyProperty::Register (this, Type::DOWNLOADER, "Uri", Type::URI);
	DependencyProperty::Register (this, Type::DOWNLOADER, "StatusText", new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::DOWNLOADER, "Status", new Value (0), Type::INT32);
	DependencyProperty::Register (this, Type::DOWNLOADER, "ResponseText", Type::STRING);
	DependencyProperty::Register (this, Type::DOWNLOADER, "DownloadProgress", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "Surface", Type::SURFACE);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "RuntimeVersion", Type::STRING);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "Parts", Type::ASSEMBLYPART_COLLECTION);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "ExternalCallersFromCrossDomain", new Value (CrossDomainAccessNoAccess), Type::INT32);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "EntryPointType", Type::STRING);
	DependencyProperty::Register (this, Type::DEPLOYMENT, "EntryPointAssembly", Type::STRING);
	DependencyProperty::Register (this, Type::COLUMNDEFINITION, "Width", new Value (GridLength (1.0, GridUnitTypeStar)), Type::GRIDLENGTH);
	DependencyProperty::Register (this, Type::COLUMNDEFINITION, "MinWidth", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::COLUMNDEFINITION, "MaxWidth", new Value (INFINITY), Type::DOUBLE);
	DependencyProperty::Register (this, Type::COLLECTION, "Count", new Value (0), Type::INT32);
	DependencyProperty::Register (this, Type::UIELEMENT, "Visibility", new Value (VisibilityVisible), Type::INT32);
	DependencyProperty::Register (this, Type::UIELEMENT, "UseLayoutRounding", new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::UIELEMENT, "Triggers", NULL, Type::TRIGGER_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::UIELEMENT, "Tag", Type::OBJECT);
	DependencyProperty::RegisterFull (this, Type::UIELEMENT, "Resources", NULL, Type::RESOURCE_DICTIONARY, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::UIELEMENT, "RenderTransform", Type::TRANSFORM);
	DependencyProperty::Register (this, Type::UIELEMENT, "RenderTransformOrigin", new Value (Point (0,0)), Type::POINT);
	DependencyProperty::Register (this, Type::UIELEMENT, "Opacity", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::UIELEMENT, "OpacityMask", Type::BRUSH);
	DependencyProperty::Register (this, Type::UIELEMENT, "IsHitTestVisible", new Value (true), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::UIELEMENT, "Cursor", new Value (MouseCursorDefault), Type::INT32, false, false, false, NULL, Validators::CursorValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::UIELEMENT, "Clip", Type::GEOMETRY);
	DependencyProperty::Register (this, Type::EASINGFUNCTIONBASE, "EasingMode", new Value (EasingModeOut), Type::INT32);
	DependencyProperty::Register (this, Type::ASSEMBLYPART, "Source", new Value (""), Type::STRING);
	DependencyProperty::RegisterFull (this, Type::APPLICATION, "Resources", NULL, Type::RESOURCE_DICTIONARY, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::RegisterFull (this, Type::SPLINECOLORKEYFRAME, "KeySpline", NULL, Type::KEYSPLINE, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::EASINGCOLORKEYFRAME, "EasingFunction", Type::EASINGFUNCTIONBASE);
	DependencyProperty::RegisterFull (this, Type::COLORANIMATIONUSINGKEYFRAMES, "KeyFrames", NULL, Type::COLORKEYFRAME_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::BITMAPIMAGE, "UriSource", new Value (Uri()), Type::URI);
	DependencyProperty::Register (this, Type::BITMAPIMAGE, "Progress", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::TRANSLATETRANSFORM, "Y", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::TRANSLATETRANSFORM, "X", new Value (0.0), Type::DOUBLE);
	DependencyProperty::RegisterFull (this, Type::TRANSFORMGROUP, "Children", NULL, Type::TRANSFORM_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::TEXTBOX, "VerticalScrollBarVisibility", new Value (ScrollBarVisibilityHidden), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBOX, "TextWrapping", new Value (TextWrappingNoWrap), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBOX, "Text", Type::STRING);
	DependencyProperty::Register (this, Type::TEXTBOX, "TextAlignment", new Value (TextAlignmentLeft), Type::INT32);
	DependencyProperty::RegisterFull (this, Type::TEXTBOX, "SelectionStart", new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::TEXTBOX, "SelectionLength", new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::TEXTBOX, "SelectionForeground", Type::BRUSH);
	DependencyProperty::Register (this, Type::TEXTBOX, "SelectionBackground", Type::BRUSH);
	DependencyProperty::Register (this, Type::TEXTBOX, "SelectedText", new Value (""), Type::STRING);
	DependencyProperty::RegisterFull (this, Type::TEXTBOX, "MaxLength", new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::TEXTBOX, "IsReadOnly", new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::TEXTBOX, "HorizontalScrollBarVisibility", new Value (ScrollBarVisibilityHidden), Type::INT32);
	DependencyProperty::Register (this, Type::TEXTBOX, "FontSource", Type::FONTSOURCE);
	DependencyProperty::Register (this, Type::TEXTBOX, "AcceptsReturn", new Value (false), Type::BOOL);
	DependencyProperty::RegisterFull (this, Type::STORYBOARD, "TargetProperty", NULL, Type::PROPERTYPATH, true, false, false, NULL, Validators::IsTimelineValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::STORYBOARD, "TargetName", NULL, Type::STRING, true, false, false, NULL, Validators::IsTimelineValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::SKEWTRANSFORM, "CenterY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SKEWTRANSFORM, "CenterX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SKEWTRANSFORM, "AngleY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SKEWTRANSFORM, "AngleX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SETTERBASE_COLLECTION, "IsSealed", new Value (false), Type::BOOL);
	DependencyProperty::Register (this, Type::SCALETRANSFORM, "ScaleY", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SCALETRANSFORM, "ScaleX", new Value (1.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SCALETRANSFORM, "CenterY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::SCALETRANSFORM, "CenterX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROTATETRANSFORM, "CenterY", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROTATETRANSFORM, "CenterX", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ROTATETRANSFORM, "Angle", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::QUADRATICBEZIERSEGMENT, "Point2", Type::POINT);
	DependencyProperty::Register (this, Type::QUADRATICBEZIERSEGMENT, "Point1", Type::POINT);
	DependencyProperty::RegisterFull (this, Type::POLYQUADRATICBEZIERSEGMENT, "Points", NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::RegisterFull (this, Type::POLYLINESEGMENT, "Points", NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::RegisterFull (this, Type::POLYBEZIERSEGMENT, "Points", NULL, Type::POINT_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::POINTKEYFRAME, "Value", Type::POINT);
	DependencyProperty::Register (this, Type::POINTKEYFRAME, "KeyTime", Type::KEYTIME);
	DependencyProperty::Register (this, Type::POINTANIMATION, "To", Type::POINT);
	DependencyProperty::Register (this, Type::POINTANIMATION, "From", Type::POINT);
	DependencyProperty::Register (this, Type::POINTANIMATION, "EasingFunction", Type::EASINGFUNCTIONBASE);
	DependencyProperty::Register (this, Type::POINTANIMATION, "By", Type::POINT);
	DependencyProperty::RegisterFull (this, Type::PASSWORDBOX, "SelectionStart", new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::PASSWORDBOX, "SelectionLength", new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "SelectionForeground", Type::BRUSH);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "SelectionBackground", Type::BRUSH);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "SelectedText", new Value (""), Type::STRING);
	DependencyProperty::RegisterFull (this, Type::PASSWORDBOX, "Password", new Value (""), Type::STRING, false, false, false, NULL, Validators::NonNullValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "PasswordChar", new Value (9679), Type::CHAR);
	DependencyProperty::RegisterFull (this, Type::PASSWORDBOX, "MaxLength", new Value (0), Type::INT32, false, false, false, NULL, Validators::PositiveIntValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::PASSWORDBOX, "FontSource", Type::FONTSOURCE);
	DependencyProperty::Register (this, Type::OBJECTKEYFRAME, "Value", Type::OBJECT);
	DependencyProperty::Register (this, Type::OBJECTKEYFRAME, "KeyTime", Type::KEYTIME);
	DependencyProperty::Register (this, Type::OBJECTANIMATIONUSINGKEYFRAMES, "KeyFrames", Type::OBJECTKEYFRAME_COLLECTION);
	DependencyProperty::Register (this, Type::MATRIXTRANSFORM, "Matrix", Type::MATRIX);
	DependencyProperty::Register (this, Type::LINESEGMENT, "Point", Type::POINT);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LayoutSlot", NULL, Type::RECT, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LayoutClip", NULL, Type::GEOMETRY, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LastRenderSize", NULL, Type::SIZE, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LastMeasure", NULL, Type::SIZE, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::LAYOUTINFORMATION, "LastArrange", NULL, Type::SIZE, true, false, false, NULL, NULL, NULL, false, false);
	DependencyProperty::Register (this, Type::EVENTTRIGGER, "RoutedEvent", Type::STRING);
	DependencyProperty::RegisterFull (this, Type::EVENTTRIGGER, "Actions", NULL, Type::TRIGGERACTION_COLLECTION, false, false, false, NULL, NULL, AutoCreators::default_autocreator, false, false);
	DependencyProperty::Register (this, Type::DOUBLEKEYFRAME, "Value", Type::DOUBLE);
	DependencyProperty::Register (this, Type::DOUBLEKEYFRAME, "KeyTime", Type::KEYTIME);
	DependencyProperty::Register (this, Type::DOUBLEANIMATION, "To", Type::DOUBLE);
	DependencyProperty::Register (this, Type::DOUBLEANIMATION, "From", Type::DOUBLE);
	DependencyProperty::Register (this, Type::DOUBLEANIMATION, "EasingFunction", Type::EASINGFUNCTIONBASE);
	DependencyProperty::Register (this, Type::DOUBLEANIMATION, "By", Type::DOUBLE);
	DependencyProperty::Register (this, Type::DEPENDENCY_OBJECT, "Name", new Value (""), Type::STRING);
	DependencyProperty::Register (this, Type::DEEPZOOMIMAGETILESOURCE, "UriSource", Type::URI);
	DependencyProperty::Register (this, Type::CONTROLTEMPLATE, "TargetType", Type::MANAGEDTYPEINFO);
	DependencyProperty::Register (this, Type::COLORKEYFRAME, "Value", Type::COLOR);
	DependencyProperty::Register (this, Type::COLORKEYFRAME, "KeyTime", Type::KEYTIME);
	DependencyProperty::Register (this, Type::COLORANIMATION, "To", Type::COLOR);
	DependencyProperty::Register (this, Type::COLORANIMATION, "From", Type::COLOR);
	DependencyProperty::Register (this, Type::COLORANIMATION, "EasingFunction", Type::EASINGFUNCTIONBASE);
	DependencyProperty::Register (this, Type::COLORANIMATION, "By", Type::COLOR);
	DependencyProperty::RegisterFull (this, Type::BITMAPSOURCE, "PixelWidth", new Value (0), Type::INT32, false, false, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false, false);
	DependencyProperty::RegisterFull (this, Type::BITMAPSOURCE, "PixelHeight", new Value (0), Type::INT32, false, false, false, NULL, Validators::IntGreaterThanZeroValidator, NULL, false, false);
	DependencyProperty::Register (this, Type::BITMAPSOURCE, "PixelFormat", new Value (PixelFormatPbgra32), Type::INT32);
	DependencyProperty::Register (this, Type::BEZIERSEGMENT, "Point3", Type::POINT);
	DependencyProperty::Register (this, Type::BEZIERSEGMENT, "Point2", Type::POINT);
	DependencyProperty::Register (this, Type::BEZIERSEGMENT, "Point1", Type::POINT);
	DependencyProperty::Register (this, Type::BEGINSTORYBOARD, "Storyboard", Type::STORYBOARD);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "SweepDirection", new Value (SweepDirectionCounterclockwise), Type::INT32);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "Size", Type::SIZE);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "RotationAngle", new Value (0.0), Type::DOUBLE);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "Point", Type::POINT);
	DependencyProperty::Register (this, Type::ARCSEGMENT, "IsLargeArc", new Value (false), Type::BOOL);
}

const int VisualBrush::VisualProperty = 0;
const int VideoBrush::SourceNameProperty = 1;
const int ImageBrush::ImageSourceProperty = 2;
const int ImageBrush::DownloadProgressProperty = 3;
const int RadialGradientBrush::RadiusYProperty = 4;
const int RadialGradientBrush::RadiusXProperty = 5;
const int RadialGradientBrush::GradientOriginProperty = 6;
const int RadialGradientBrush::CenterProperty = 7;
const int LinearGradientBrush::StartPointProperty = 8;
const int LinearGradientBrush::EndPointProperty = 9;
const int SolidColorBrush::ColorProperty = 10;
const int TileBrush::StretchProperty = 11;
const int TileBrush::AlignmentYProperty = 12;
const int TileBrush::AlignmentXProperty = 13;
const int GradientBrush::SpreadMethodProperty = 14;
const int GradientBrush::MappingModeProperty = 15;
const int GradientBrush::GradientStopsProperty = 16;
const int GradientBrush::ColorInterpolationModeProperty = 17;
const int InkPresenter::StrokesProperty = 18;
const int Brush::TransformProperty = 19;
const int Brush::RelativeTransformProperty = 20;
const int Brush::OpacityProperty = 21;
const int Brush::ChangedProperty = 22;
const int Rectangle::RadiusYProperty = 23;
const int Rectangle::RadiusXProperty = 24;
const int Polyline::PointsProperty = 25;
const int Polyline::FillRuleProperty = 26;
const int Polygon::PointsProperty = 27;
const int Polygon::FillRuleProperty = 28;
const int Path::DataProperty = 29;
const int Line::Y2Property = 30;
const int Line::Y1Property = 31;
const int Line::X2Property = 32;
const int Line::X1Property = 33;
const int MultiScaleImage::ViewportWidthProperty = 34;
const int MultiScaleImage::ViewportOriginProperty = 35;
const int MultiScaleImage::UseSpringsProperty = 36;
const int MultiScaleImage::TileFadeProperty = 37;
const int MultiScaleImage::SubImagesProperty = 38;
const int MultiScaleImage::SourceProperty = 39;
const int MultiScaleImage::IsIdleProperty = 40;
const int MultiScaleImage::IsDownloadingProperty = 41;
const int MultiScaleImage::BlurFactorProperty = 42;
const int MultiScaleImage::AspectRatioProperty = 43;
const int MultiScaleImage::AllowDownloadingProperty = 44;
const int Image::SourceProperty = 45;
const int UserControl::ContentProperty = 46;
const int ContentControl::ContentTemplateProperty = 47;
const int ContentControl::ContentProperty = 48;
const int Grid::ShowGridLinesProperty = 49;
const int Grid::RowSpanProperty = 50;
const int Grid::RowProperty = 51;
const int Grid::RowDefinitionsProperty = 52;
const int Grid::ColumnSpanProperty = 53;
const int Grid::ColumnProperty = 54;
const int Grid::ColumnDefinitionsProperty = 55;
const int Canvas::ZIndexProperty = 56;
const int Canvas::TopProperty = 57;
const int Canvas::LeftProperty = 58;
const int TextBlock::TextWrappingProperty = 59;
const int TextBlock::TextProperty = 60;
const int TextBlock::TextDecorationsProperty = 61;
const int TextBlock::TextAlignmentProperty = 62;
const int TextBlock::PaddingProperty = 63;
const int TextBlock::LineStackingStrategyProperty = 64;
const int TextBlock::LineHeightProperty = 65;
const int TextBlock::InlinesProperty = 66;
const int TextBlock::ForegroundProperty = 67;
const int TextBlock::FontWeightProperty = 68;
const int TextBlock::FontStyleProperty = 69;
const int TextBlock::FontStretchProperty = 70;
const int TextBlock::FontSourceProperty = 71;
const int TextBlock::FontSizeProperty = 72;
const int TextBlock::FontGUIDProperty = 73;
const int TextBlock::FontFilenameProperty = 74;
const int TextBlock::FontFamilyProperty = 75;
const int Popup::VerticalOffsetProperty = 76;
const int Popup::IsOpenProperty = 77;
const int Popup::HorizontalOffsetProperty = 78;
const int Popup::ChildProperty = 79;
const int MediaElement::VolumeProperty = 80;
const int MediaElement::StretchProperty = 81;
const int MediaElement::SourceProperty = 82;
const int MediaElement::RenderedFramesPerSecondProperty = 83;
const int MediaElement::PositionProperty = 84;
const int MediaElement::NaturalVideoWidthProperty = 85;
const int MediaElement::NaturalVideoHeightProperty = 86;
const int MediaElement::NaturalDurationProperty = 87;
const int MediaElement::MarkersProperty = 88;
const int MediaElement::IsMutedProperty = 89;
const int MediaElement::DroppedFramesPerSecondProperty = 90;
const int MediaElement::DownloadProgressProperty = 91;
const int MediaElement::DownloadProgressOffsetProperty = 92;
const int MediaElement::CurrentStateProperty = 93;
const int MediaElement::CanSeekProperty = 94;
const int MediaElement::CanPauseProperty = 95;
const int MediaElement::BufferingTimeProperty = 96;
const int MediaElement::BufferingProgressProperty = 97;
const int MediaElement::BalanceProperty = 98;
const int MediaElement::AutoPlayProperty = 99;
const int MediaElement::AudioStreamIndexProperty = 100;
const int MediaElement::AudioStreamCountProperty = 101;
const int MediaElement::AttributesProperty = 102;
const int Shape::StrokeThicknessProperty = 103;
const int Shape::StrokeStartLineCapProperty = 104;
const int Shape::StrokeProperty = 105;
const int Shape::StrokeMiterLimitProperty = 106;
const int Shape::StrokeLineJoinProperty = 107;
const int Shape::StrokeEndLineCapProperty = 108;
const int Shape::StrokeDashOffsetProperty = 109;
const int Shape::StrokeDashCapProperty = 110;
const int Shape::StrokeDashArrayProperty = 111;
const int Shape::StretchProperty = 112;
const int Shape::FillProperty = 113;
const int MediaBase::StretchProperty = 114;
const int MediaBase::SourceProperty = 115;
const int MediaBase::DownloadProgressProperty = 116;
const int Glyphs::UnicodeStringProperty = 117;
const int Glyphs::StyleSimulationsProperty = 118;
const int Glyphs::OriginYProperty = 119;
const int Glyphs::OriginXProperty = 120;
const int Glyphs::IndicesProperty = 121;
const int Glyphs::FontUriProperty = 122;
const int Glyphs::FontRenderingEmSizeProperty = 123;
const int Glyphs::FillProperty = 124;
const int Control::VerticalContentAlignmentProperty = 125;
const int Control::TemplateProperty = 126;
const int Control::TabNavigationProperty = 127;
const int Control::TabIndexProperty = 128;
const int Control::PaddingProperty = 129;
const int Control::IsTabStopProperty = 130;
const int Control::HorizontalContentAlignmentProperty = 131;
const int Control::ForegroundProperty = 132;
const int Control::FontWeightProperty = 133;
const int Control::FontStyleProperty = 134;
const int Control::FontStretchProperty = 135;
const int Control::FontSizeProperty = 136;
const int Control::FontFamilyProperty = 137;
const int Control::DefaultStyleKeyProperty = 138;
const int Control::BorderThicknessProperty = 139;
const int Control::BorderBrushProperty = 140;
const int Control::BackgroundProperty = 141;
const int Panel::ChildrenProperty = 142;
const int Panel::BackgroundProperty = 143;
const int Border::PaddingProperty = 144;
const int Border::CornerRadiusProperty = 145;
const int Border::ChildProperty = 146;
const int Border::BorderThicknessProperty = 147;
const int Border::BorderBrushProperty = 148;
const int Border::BackgroundProperty = 149;
const int TimelineGroup::ChildrenProperty = 150;
const int Setter::ValueProperty = 151;
const int Setter::PropertyProperty = 152;
const int Setter::ConvertedValueProperty = 153;
const int Run::TextProperty = 154;
const int RectangleGeometry::RectProperty = 155;
const int RectangleGeometry::RadiusYProperty = 156;
const int RectangleGeometry::RadiusXProperty = 157;
const int PathGeometry::FillRuleProperty = 158;
const int PathGeometry::FiguresProperty = 159;
const int LineGeometry::StartPointProperty = 160;
const int LineGeometry::EndPointProperty = 161;
const int GeometryGroup::FillRuleProperty = 162;
const int GeometryGroup::ChildrenProperty = 163;
const int EllipseGeometry::RadiusYProperty = 164;
const int EllipseGeometry::RadiusXProperty = 165;
const int EllipseGeometry::CenterProperty = 166;
const int FrameworkElement::WidthProperty = 167;
const int FrameworkElement::VerticalAlignmentProperty = 168;
const int FrameworkElement::StyleProperty = 169;
const int FrameworkElement::MinWidthProperty = 170;
const int FrameworkElement::MinHeightProperty = 171;
const int FrameworkElement::MaxWidthProperty = 172;
const int FrameworkElement::MaxHeightProperty = 173;
const int FrameworkElement::MarginProperty = 174;
const int FrameworkElement::LanguageProperty = 175;
const int FrameworkElement::HorizontalAlignmentProperty = 176;
const int FrameworkElement::HeightProperty = 177;
const int FrameworkElement::DataContextProperty = 178;
const int FrameworkElement::ActualWidthProperty = 179;
const int FrameworkElement::ActualHeightProperty = 180;
const int PowerEase::PowerProperty = 181;
const int ExponentialEase::ExponentProperty = 182;
const int ElasticEase::SpringinessProperty = 183;
const int ElasticEase::OscillationsProperty = 184;
const int BounceEase::BouncinessProperty = 185;
const int BounceEase::BouncesProperty = 186;
const int BackEase::AmplitudeProperty = 187;
const int SplinePointKeyFrame::KeySplineProperty = 188;
const int EasingPointKeyFrame::EasingFunctionProperty = 189;
const int PointAnimationUsingKeyFrames::KeyFramesProperty = 190;
const int SplineDoubleKeyFrame::KeySplineProperty = 191;
const int EasingDoubleKeyFrame::EasingFunctionProperty = 192;
const int DoubleAnimationUsingKeyFrames::KeyFramesProperty = 193;
const int TimelineMarker::TypeProperty = 194;
const int TimelineMarker::TimeProperty = 195;
const int TimelineMarker::TextProperty = 196;
const int Timeline::SpeedRatioProperty = 197;
const int Timeline::RepeatBehaviorProperty = 198;
const int Timeline::FillBehaviorProperty = 199;
const int Timeline::DurationProperty = 200;
const int Timeline::BeginTimeProperty = 201;
const int Timeline::AutoReverseProperty = 202;
const int StylusPoint::YProperty = 203;
const int StylusPoint::XProperty = 204;
const int StylusPoint::PressureFactorProperty = 205;
const int StylusInfo::IsInvertedProperty = 206;
const int StylusInfo::DeviceTypeProperty = 207;
const int Style::TargetTypeProperty = 208;
const int Style::SettersProperty = 209;
const int Style::IsSealedProperty = 210;
const int Stroke::StylusPointsProperty = 211;
const int Stroke::DrawingAttributesProperty = 212;
const int SetterBase::IsSealedProperty = 213;
const int RowDefinition::MinHeightProperty = 214;
const int RowDefinition::MaxHeightProperty = 215;
const int RowDefinition::HeightProperty = 216;
const int PathFigure::StartPointProperty = 217;
const int PathFigure::SegmentsProperty = 218;
const int PathFigure::IsFilledProperty = 219;
const int PathFigure::IsClosedProperty = 220;
const int NameScope::NameScopeProperty = 221;
const int MultiScaleSubImage::ZIndexProperty = 222;
const int MultiScaleSubImage::ViewportWidthProperty = 223;
const int MultiScaleSubImage::ViewportOriginProperty = 224;
const int MultiScaleSubImage::OpacityProperty = 225;
const int MultiScaleSubImage::AspectRatioProperty = 226;
const int MediaAttribute::ValueProperty = 227;
const int Matrix::OffsetYProperty = 228;
const int Matrix::OffsetXProperty = 229;
const int Matrix::M22Property = 230;
const int Matrix::M21Property = 231;
const int Matrix::M12Property = 232;
const int Matrix::M11Property = 233;
const int KeySpline::ControlPoint2Property = 234;
const int KeySpline::ControlPoint1Property = 235;
const int InputMethod::IsInputMethodEnabledProperty = 236;
const int Inline::TextDecorationsProperty = 237;
const int Inline::LanguageProperty = 238;
const int Inline::ForegroundProperty = 239;
const int Inline::FontWeightProperty = 240;
const int Inline::FontStyleProperty = 241;
const int Inline::FontStretchProperty = 242;
const int Inline::FontSourceProperty = 243;
const int Inline::FontSizeProperty = 244;
const int Inline::FontGUIDProperty = 245;
const int Inline::FontFilenameProperty = 246;
const int Inline::FontFamilyProperty = 247;
const int GradientStop::OffsetProperty = 248;
const int GradientStop::ColorProperty = 249;
const int Geometry::TransformProperty = 250;
const int DrawingAttributes::WidthProperty = 251;
const int DrawingAttributes::OutlineColorProperty = 252;
const int DrawingAttributes::HeightProperty = 253;
const int DrawingAttributes::ColorProperty = 254;
const int Downloader::UriProperty = 255;
const int Downloader::StatusTextProperty = 256;
const int Downloader::StatusProperty = 257;
const int Downloader::ResponseTextProperty = 258;
const int Downloader::DownloadProgressProperty = 259;
const int Deployment::SurfaceProperty = 260;
const int Deployment::RuntimeVersionProperty = 261;
const int Deployment::PartsProperty = 262;
const int Deployment::ExternalCallersFromCrossDomainProperty = 263;
const int Deployment::EntryPointTypeProperty = 264;
const int Deployment::EntryPointAssemblyProperty = 265;
const int ColumnDefinition::WidthProperty = 266;
const int ColumnDefinition::MinWidthProperty = 267;
const int ColumnDefinition::MaxWidthProperty = 268;
const int Collection::CountProperty = 269;
const int UIElement::VisibilityProperty = 270;
const int UIElement::UseLayoutRoundingProperty = 271;
const int UIElement::TriggersProperty = 272;
const int UIElement::TagProperty = 273;
const int UIElement::ResourcesProperty = 274;
const int UIElement::RenderTransformProperty = 275;
const int UIElement::RenderTransformOriginProperty = 276;
const int UIElement::OpacityProperty = 277;
const int UIElement::OpacityMaskProperty = 278;
const int UIElement::IsHitTestVisibleProperty = 279;
const int UIElement::CursorProperty = 280;
const int UIElement::ClipProperty = 281;
const int EasingFunctionBase::EasingModeProperty = 282;
const int AssemblyPart::SourceProperty = 283;
const int Application::ResourcesProperty = 284;
const int SplineColorKeyFrame::KeySplineProperty = 285;
const int EasingColorKeyFrame::EasingFunctionProperty = 286;
const int ColorAnimationUsingKeyFrames::KeyFramesProperty = 287;
const int BitmapImage::UriSourceProperty = 288;
const int BitmapImage::ProgressProperty = 289;
const int TranslateTransform::YProperty = 290;
const int TranslateTransform::XProperty = 291;
const int TransformGroup::ChildrenProperty = 292;
const int TextBox::VerticalScrollBarVisibilityProperty = 293;
const int TextBox::TextWrappingProperty = 294;
const int TextBox::TextProperty = 295;
const int TextBox::TextAlignmentProperty = 296;
const int TextBox::SelectionStartProperty = 297;
const int TextBox::SelectionLengthProperty = 298;
const int TextBox::SelectionForegroundProperty = 299;
const int TextBox::SelectionBackgroundProperty = 300;
const int TextBox::SelectedTextProperty = 301;
const int TextBox::MaxLengthProperty = 302;
const int TextBox::IsReadOnlyProperty = 303;
const int TextBox::HorizontalScrollBarVisibilityProperty = 304;
const int TextBox::FontSourceProperty = 305;
const int TextBox::AcceptsReturnProperty = 306;
const int Storyboard::TargetPropertyProperty = 307;
const int Storyboard::TargetNameProperty = 308;
const int SkewTransform::CenterYProperty = 309;
const int SkewTransform::CenterXProperty = 310;
const int SkewTransform::AngleYProperty = 311;
const int SkewTransform::AngleXProperty = 312;
const int SetterBaseCollection::IsSealedProperty = 313;
const int ScaleTransform::ScaleYProperty = 314;
const int ScaleTransform::ScaleXProperty = 315;
const int ScaleTransform::CenterYProperty = 316;
const int ScaleTransform::CenterXProperty = 317;
const int RotateTransform::CenterYProperty = 318;
const int RotateTransform::CenterXProperty = 319;
const int RotateTransform::AngleProperty = 320;
const int QuadraticBezierSegment::Point2Property = 321;
const int QuadraticBezierSegment::Point1Property = 322;
const int PolyQuadraticBezierSegment::PointsProperty = 323;
const int PolyLineSegment::PointsProperty = 324;
const int PolyBezierSegment::PointsProperty = 325;
const int PointKeyFrame::ValueProperty = 326;
const int PointKeyFrame::KeyTimeProperty = 327;
const int PointAnimation::ToProperty = 328;
const int PointAnimation::FromProperty = 329;
const int PointAnimation::EasingFunctionProperty = 330;
const int PointAnimation::ByProperty = 331;
const int PasswordBox::SelectionStartProperty = 332;
const int PasswordBox::SelectionLengthProperty = 333;
const int PasswordBox::SelectionForegroundProperty = 334;
const int PasswordBox::SelectionBackgroundProperty = 335;
const int PasswordBox::SelectedTextProperty = 336;
const int PasswordBox::PasswordProperty = 337;
const int PasswordBox::PasswordCharProperty = 338;
const int PasswordBox::MaxLengthProperty = 339;
const int PasswordBox::FontSourceProperty = 340;
const int ObjectKeyFrame::ValueProperty = 341;
const int ObjectKeyFrame::KeyTimeProperty = 342;
const int ObjectAnimationUsingKeyFrames::KeyFramesProperty = 343;
const int MatrixTransform::MatrixProperty = 344;
const int LineSegment::PointProperty = 345;
const int LayoutInformation::LayoutSlotProperty = 346;
const int LayoutInformation::LayoutClipProperty = 347;
const int LayoutInformation::LastRenderSizeProperty = 348;
const int LayoutInformation::LastMeasureProperty = 349;
const int LayoutInformation::LastArrangeProperty = 350;
const int EventTrigger::RoutedEventProperty = 351;
const int EventTrigger::ActionsProperty = 352;
const int DoubleKeyFrame::ValueProperty = 353;
const int DoubleKeyFrame::KeyTimeProperty = 354;
const int DoubleAnimation::ToProperty = 355;
const int DoubleAnimation::FromProperty = 356;
const int DoubleAnimation::EasingFunctionProperty = 357;
const int DoubleAnimation::ByProperty = 358;
const int DependencyObject::NameProperty = 359;
const int DeepZoomImageTileSource::UriSourceProperty = 360;
const int ControlTemplate::TargetTypeProperty = 361;
const int ColorKeyFrame::ValueProperty = 362;
const int ColorKeyFrame::KeyTimeProperty = 363;
const int ColorAnimation::ToProperty = 364;
const int ColorAnimation::FromProperty = 365;
const int ColorAnimation::EasingFunctionProperty = 366;
const int ColorAnimation::ByProperty = 367;
const int BitmapSource::PixelWidthProperty = 368;
const int BitmapSource::PixelHeightProperty = 369;
const int BitmapSource::PixelFormatProperty = 370;
const int BezierSegment::Point3Property = 371;
const int BezierSegment::Point2Property = 372;
const int BezierSegment::Point1Property = 373;
const int BeginStoryboard::StoryboardProperty = 374;
const int ArcSegment::SweepDirectionProperty = 375;
const int ArcSegment::SizeProperty = 376;
const int ArcSegment::RotationAngleProperty = 377;
const int ArcSegment::PointProperty = 378;
const int ArcSegment::IsLargeArcProperty = 379;

UIElement *
VisualBrush::GetVisual ()
{
	Value *value = GetValue (VisualBrush::VisualProperty);
	return value ? value->AsUIElement () : NULL;
}

void
VisualBrush::SetVisual (UIElement *value)
{
	SetValue (VisualBrush::VisualProperty, Value (value));
}

const char *
VideoBrush::GetSourceName ()
{
	Value *value = GetValue (VideoBrush::SourceNameProperty);
	return value ? value->AsString () : NULL;
}

void
VideoBrush::SetSourceName (const char *value)
{
	SetValue (VideoBrush::SourceNameProperty, Value (value));
}

ImageSource *
ImageBrush::GetImageSource ()
{
	Value *value = GetValue (ImageBrush::ImageSourceProperty);
	return value ? value->AsImageSource () : NULL;
}

void
ImageBrush::SetImageSource (ImageSource *value)
{
	SetValue (ImageBrush::ImageSourceProperty, Value (value));
}

double
ImageBrush::GetDownloadProgress ()
{
	Value *value = GetValue (ImageBrush::DownloadProgressProperty);
	return value->AsDouble ();
}

void
ImageBrush::SetDownloadProgress (double value)
{
	SetValue (ImageBrush::DownloadProgressProperty, Value (value));
}

double
RadialGradientBrush::GetRadiusY ()
{
	Value *value = GetValue (RadialGradientBrush::RadiusYProperty);
	return value->AsDouble ();
}

void
RadialGradientBrush::SetRadiusY (double value)
{
	SetValue (RadialGradientBrush::RadiusYProperty, Value (value));
}

double
RadialGradientBrush::GetRadiusX ()
{
	Value *value = GetValue (RadialGradientBrush::RadiusXProperty);
	return value->AsDouble ();
}

void
RadialGradientBrush::SetRadiusX (double value)
{
	SetValue (RadialGradientBrush::RadiusXProperty, Value (value));
}

Point *
RadialGradientBrush::GetGradientOrigin ()
{
	Value *value = GetValue (RadialGradientBrush::GradientOriginProperty);
	return value ? value->AsPoint () : NULL;
}

void
RadialGradientBrush::SetGradientOrigin (Point *value)
{
	if (!value) return;
	SetValue (RadialGradientBrush::GradientOriginProperty, Value (*value));
}

Point *
RadialGradientBrush::GetCenter ()
{
	Value *value = GetValue (RadialGradientBrush::CenterProperty);
	return value ? value->AsPoint () : NULL;
}

void
RadialGradientBrush::SetCenter (Point *value)
{
	if (!value) return;
	SetValue (RadialGradientBrush::CenterProperty, Value (*value));
}

Point *
LinearGradientBrush::GetStartPoint ()
{
	Value *value = GetValue (LinearGradientBrush::StartPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LinearGradientBrush::SetStartPoint (Point *value)
{
	if (!value) return;
	SetValue (LinearGradientBrush::StartPointProperty, Value (*value));
}

Point *
LinearGradientBrush::GetEndPoint ()
{
	Value *value = GetValue (LinearGradientBrush::EndPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LinearGradientBrush::SetEndPoint (Point *value)
{
	if (!value) return;
	SetValue (LinearGradientBrush::EndPointProperty, Value (*value));
}

Color *
SolidColorBrush::GetColor ()
{
	Value *value = GetValue (SolidColorBrush::ColorProperty);
	return value ? value->AsColor () : NULL;
}

void
SolidColorBrush::SetColor (Color *value)
{
	if (!value) return;
	SetValue (SolidColorBrush::ColorProperty, Value (*value));
}

Stretch
TileBrush::GetStretch ()
{
	Value *value = GetValue (TileBrush::StretchProperty);
	return (Stretch) value->AsInt32 ();
}

void
TileBrush::SetStretch (Stretch value)
{
	SetValue (TileBrush::StretchProperty, Value (value));
}

AlignmentY
TileBrush::GetAlignmentY ()
{
	Value *value = GetValue (TileBrush::AlignmentYProperty);
	return (AlignmentY) value->AsInt32 ();
}

void
TileBrush::SetAlignmentY (AlignmentY value)
{
	SetValue (TileBrush::AlignmentYProperty, Value (value));
}

AlignmentX
TileBrush::GetAlignmentX ()
{
	Value *value = GetValue (TileBrush::AlignmentXProperty);
	return (AlignmentX) value->AsInt32 ();
}

void
TileBrush::SetAlignmentX (AlignmentX value)
{
	SetValue (TileBrush::AlignmentXProperty, Value (value));
}

GradientSpreadMethod
GradientBrush::GetSpreadMethod ()
{
	Value *value = GetValue (GradientBrush::SpreadMethodProperty);
	return (GradientSpreadMethod) value->AsInt32 ();
}

void
GradientBrush::SetSpreadMethod (GradientSpreadMethod value)
{
	SetValue (GradientBrush::SpreadMethodProperty, Value (value));
}

BrushMappingMode
GradientBrush::GetMappingMode ()
{
	Value *value = GetValue (GradientBrush::MappingModeProperty);
	return (BrushMappingMode) value->AsInt32 ();
}

void
GradientBrush::SetMappingMode (BrushMappingMode value)
{
	SetValue (GradientBrush::MappingModeProperty, Value (value));
}

GradientStopCollection *
GradientBrush::GetGradientStops ()
{
	Value *value = GetValue (GradientBrush::GradientStopsProperty);
	return value ? value->AsGradientStopCollection () : NULL;
}

void
GradientBrush::SetGradientStops (GradientStopCollection *value)
{
	SetValue (GradientBrush::GradientStopsProperty, Value (value));
}

ColorInterpolationMode
GradientBrush::GetColorInterpolationMode ()
{
	Value *value = GetValue (GradientBrush::ColorInterpolationModeProperty);
	return (ColorInterpolationMode) value->AsInt32 ();
}

void
GradientBrush::SetColorInterpolationMode (ColorInterpolationMode value)
{
	SetValue (GradientBrush::ColorInterpolationModeProperty, Value (value));
}

StrokeCollection *
InkPresenter::GetStrokes ()
{
	Value *value = GetValue (InkPresenter::StrokesProperty);
	return value ? value->AsStrokeCollection () : NULL;
}

void
InkPresenter::SetStrokes (StrokeCollection *value)
{
	SetValue (InkPresenter::StrokesProperty, Value (value));
}

Transform *
Brush::GetTransform ()
{
	Value *value = GetValue (Brush::TransformProperty);
	return value ? value->AsTransform () : NULL;
}

void
Brush::SetTransform (Transform *value)
{
	SetValue (Brush::TransformProperty, Value (value));
}

Transform *
Brush::GetRelativeTransform ()
{
	Value *value = GetValue (Brush::RelativeTransformProperty);
	return value ? value->AsTransform () : NULL;
}

void
Brush::SetRelativeTransform (Transform *value)
{
	SetValue (Brush::RelativeTransformProperty, Value (value));
}

double
Brush::GetOpacity ()
{
	Value *value = GetValue (Brush::OpacityProperty);
	return value->AsDouble ();
}

void
Brush::SetOpacity (double value)
{
	SetValue (Brush::OpacityProperty, Value (value));
}

double
Rectangle::GetRadiusY ()
{
	Value *value = GetValue (Rectangle::RadiusYProperty);
	return value->AsDouble ();
}

void
Rectangle::SetRadiusY (double value)
{
	SetValue (Rectangle::RadiusYProperty, Value (value));
}

double
Rectangle::GetRadiusX ()
{
	Value *value = GetValue (Rectangle::RadiusXProperty);
	return value->AsDouble ();
}

void
Rectangle::SetRadiusX (double value)
{
	SetValue (Rectangle::RadiusXProperty, Value (value));
}

PointCollection *
Polyline::GetPoints ()
{
	Value *value = GetValue (Polyline::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
Polyline::SetPoints (PointCollection *value)
{
	SetValue (Polyline::PointsProperty, Value (value));
}

FillRule
Polyline::GetFillRule ()
{
	Value *value = GetValue (Polyline::FillRuleProperty);
	return (FillRule) value->AsInt32 ();
}

void
Polyline::SetFillRule (FillRule value)
{
	SetValue (Polyline::FillRuleProperty, Value (value));
}

PointCollection *
Polygon::GetPoints ()
{
	Value *value = GetValue (Polygon::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
Polygon::SetPoints (PointCollection *value)
{
	SetValue (Polygon::PointsProperty, Value (value));
}

FillRule
Polygon::GetFillRule ()
{
	Value *value = GetValue (Polygon::FillRuleProperty);
	return (FillRule) value->AsInt32 ();
}

void
Polygon::SetFillRule (FillRule value)
{
	SetValue (Polygon::FillRuleProperty, Value (value));
}

Geometry *
Path::GetData ()
{
	Value *value = GetValue (Path::DataProperty);
	return value ? value->AsGeometry () : NULL;
}

void
Path::SetData (Geometry *value)
{
	SetValue (Path::DataProperty, Value (value));
}

double
Line::GetY2 ()
{
	Value *value = GetValue (Line::Y2Property);
	return value->AsDouble ();
}

void
Line::SetY2 (double value)
{
	SetValue (Line::Y2Property, Value (value));
}

double
Line::GetY1 ()
{
	Value *value = GetValue (Line::Y1Property);
	return value->AsDouble ();
}

void
Line::SetY1 (double value)
{
	SetValue (Line::Y1Property, Value (value));
}

double
Line::GetX2 ()
{
	Value *value = GetValue (Line::X2Property);
	return value->AsDouble ();
}

void
Line::SetX2 (double value)
{
	SetValue (Line::X2Property, Value (value));
}

double
Line::GetX1 ()
{
	Value *value = GetValue (Line::X1Property);
	return value->AsDouble ();
}

void
Line::SetX1 (double value)
{
	SetValue (Line::X1Property, Value (value));
}

double
MultiScaleImage::GetViewportWidth ()
{
	Value *value = GetValue (MultiScaleImage::ViewportWidthProperty);
	return value->AsDouble ();
}

Point *
MultiScaleImage::GetViewportOrigin ()
{
	Value *value = GetValue (MultiScaleImage::ViewportOriginProperty);
	return value ? value->AsPoint () : NULL;
}

bool
MultiScaleImage::GetUseSprings ()
{
	Value *value = GetValue (MultiScaleImage::UseSpringsProperty);
	return value->AsBool ();
}

void
MultiScaleImage::SetUseSprings (bool value)
{
	SetValue (MultiScaleImage::UseSpringsProperty, Value (value));
}

MultiScaleSubImageCollection *
MultiScaleImage::GetSubImages ()
{
	Value *value = GetValue (MultiScaleImage::SubImagesProperty);
	return value ? value->AsMultiScaleSubImageCollection () : NULL;
}

MultiScaleTileSource *
MultiScaleImage::GetSource ()
{
	Value *value = GetValue (MultiScaleImage::SourceProperty);
	return value ? value->AsMultiScaleTileSource () : NULL;
}

void
MultiScaleImage::SetSource (MultiScaleTileSource *value)
{
	SetValue (MultiScaleImage::SourceProperty, Value (value));
}

bool
MultiScaleImage::GetIsIdle ()
{
	Value *value = GetValue (MultiScaleImage::IsIdleProperty);
	return value->AsBool ();
}

bool
MultiScaleImage::GetIsDownloading ()
{
	Value *value = GetValue (MultiScaleImage::IsDownloadingProperty);
	return value->AsBool ();
}

double
MultiScaleImage::GetBlurFactor ()
{
	Value *value = GetValue (MultiScaleImage::BlurFactorProperty);
	return value->AsDouble ();
}

void
MultiScaleImage::SetBlurFactor (double value)
{
	SetValue (MultiScaleImage::BlurFactorProperty, Value (value));
}

double
MultiScaleImage::GetAspectRatio ()
{
	Value *value = GetValue (MultiScaleImage::AspectRatioProperty);
	return value->AsDouble ();
}

bool
MultiScaleImage::GetAllowDownloading ()
{
	Value *value = GetValue (MultiScaleImage::AllowDownloadingProperty);
	return value->AsBool ();
}

void
MultiScaleImage::SetAllowDownloading (bool value)
{
	SetValue (MultiScaleImage::AllowDownloadingProperty, Value (value));
}

ImageSource *
Image::GetSource ()
{
	Value *value = GetValue (Image::SourceProperty);
	return value ? value->AsImageSource () : NULL;
}

void
Image::SetSource (ImageSource *value)
{
	SetValue (Image::SourceProperty, Value (value));
}

DataTemplate *
ContentControl::GetContentTemplate ()
{
	Value *value = GetValue (ContentControl::ContentTemplateProperty);
	return value ? value->AsDataTemplate () : NULL;
}

void
ContentControl::SetContentTemplate (DataTemplate *value)
{
	SetValue (ContentControl::ContentTemplateProperty, Value (value));
}

bool
Grid::GetShowGridLines ()
{
	Value *value = GetValue (Grid::ShowGridLinesProperty);
	return value->AsBool ();
}

void
Grid::SetShowGridLines (bool value)
{
	SetValue (Grid::ShowGridLinesProperty, Value (value));
}

gint32
Grid::GetRowSpan (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Grid::RowSpanProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Grid::RowSpanProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Grid::SetRowSpan (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Grid::RowSpanProperty, Value (value));
}

gint32
Grid::GetRow (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Grid::RowProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Grid::RowProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Grid::SetRow (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Grid::RowProperty, Value (value));
}

RowDefinitionCollection *
Grid::GetRowDefinitions ()
{
	Value *value = GetValue (Grid::RowDefinitionsProperty);
	return value ? value->AsRowDefinitionCollection () : NULL;
}

void
Grid::SetRowDefinitions (RowDefinitionCollection *value)
{
	SetValue (Grid::RowDefinitionsProperty, Value (value));
}

gint32
Grid::GetColumnSpan (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Grid::ColumnSpanProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Grid::ColumnSpanProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Grid::SetColumnSpan (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Grid::ColumnSpanProperty, Value (value));
}

gint32
Grid::GetColumn (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Grid::ColumnProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Grid::ColumnProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Grid::SetColumn (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Grid::ColumnProperty, Value (value));
}

ColumnDefinitionCollection *
Grid::GetColumnDefinitions ()
{
	Value *value = GetValue (Grid::ColumnDefinitionsProperty);
	return value ? value->AsColumnDefinitionCollection () : NULL;
}

void
Grid::SetColumnDefinitions (ColumnDefinitionCollection *value)
{
	SetValue (Grid::ColumnDefinitionsProperty, Value (value));
}

gint32
Canvas::GetZIndex (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Canvas::ZIndexProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Canvas::ZIndexProperty)->GetDefaultValue();
	return value->AsInt32 ();
}

void
Canvas::SetZIndex (DependencyObject *obj, gint32 value)
{
	if (!obj) return;
	obj->SetValue (Canvas::ZIndexProperty, Value (value));
}

double
Canvas::GetTop (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Canvas::TopProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Canvas::TopProperty)->GetDefaultValue();
	return value->AsDouble ();
}

void
Canvas::SetTop (DependencyObject *obj, double value)
{
	if (!obj) return;
	obj->SetValue (Canvas::TopProperty, Value (value));
}

double
Canvas::GetLeft (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Canvas::LeftProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Canvas::LeftProperty)->GetDefaultValue();
	return value->AsDouble ();
}

void
Canvas::SetLeft (DependencyObject *obj, double value)
{
	if (!obj) return;
	obj->SetValue (Canvas::LeftProperty, Value (value));
}

TextWrapping
TextBlock::GetTextWrapping ()
{
	Value *value = GetValue (TextBlock::TextWrappingProperty);
	return (TextWrapping) value->AsInt32 ();
}

void
TextBlock::SetTextWrapping (TextWrapping value)
{
	SetValue (TextBlock::TextWrappingProperty, Value (value));
}

const char *
TextBlock::GetText ()
{
	Value *value = GetValue (TextBlock::TextProperty);
	return value ? value->AsString () : NULL;
}

void
TextBlock::SetText (const char *value)
{
	SetValue (TextBlock::TextProperty, Value (value));
}

TextDecorations
TextBlock::GetTextDecorations ()
{
	Value *value = GetValue (TextBlock::TextDecorationsProperty);
	return (TextDecorations) value->AsInt32 ();
}

void
TextBlock::SetTextDecorations (TextDecorations value)
{
	SetValue (TextBlock::TextDecorationsProperty, Value (value));
}

TextAlignment
TextBlock::GetTextAlignment ()
{
	Value *value = GetValue (TextBlock::TextAlignmentProperty);
	return (TextAlignment) value->AsInt32 ();
}

void
TextBlock::SetTextAlignment (TextAlignment value)
{
	SetValue (TextBlock::TextAlignmentProperty, Value (value));
}

Thickness *
TextBlock::GetPadding ()
{
	Value *value = GetValue (TextBlock::PaddingProperty);
	return value ? value->AsThickness () : NULL;
}

void
TextBlock::SetPadding (Thickness *value)
{
	if (!value) return;
	SetValue (TextBlock::PaddingProperty, Value (*value));
}

LineStackingStrategy
TextBlock::GetLineStackingStrategy ()
{
	Value *value = GetValue (TextBlock::LineStackingStrategyProperty);
	return (LineStackingStrategy) value->AsInt32 ();
}

void
TextBlock::SetLineStackingStrategy (LineStackingStrategy value)
{
	SetValue (TextBlock::LineStackingStrategyProperty, Value (value));
}

double
TextBlock::GetLineHeight ()
{
	Value *value = GetValue (TextBlock::LineHeightProperty);
	return value->AsDouble ();
}

void
TextBlock::SetLineHeight (double value)
{
	SetValue (TextBlock::LineHeightProperty, Value (value));
}

InlineCollection *
TextBlock::GetInlines ()
{
	Value *value = GetValue (TextBlock::InlinesProperty);
	return value ? value->AsInlineCollection () : NULL;
}

void
TextBlock::SetInlines (InlineCollection *value)
{
	SetValue (TextBlock::InlinesProperty, Value (value));
}

Brush *
TextBlock::GetForeground ()
{
	Value *value = GetValue (TextBlock::ForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
TextBlock::SetForeground (Brush *value)
{
	SetValue (TextBlock::ForegroundProperty, Value (value));
}

FontWeights
TextBlock::GetFontWeight ()
{
	Value *value = GetValue (TextBlock::FontWeightProperty);
	return (FontWeights) value->AsInt32 ();
}

void
TextBlock::SetFontWeight (FontWeights value)
{
	SetValue (TextBlock::FontWeightProperty, Value (value));
}

FontStyles
TextBlock::GetFontStyle ()
{
	Value *value = GetValue (TextBlock::FontStyleProperty);
	return (FontStyles) value->AsInt32 ();
}

void
TextBlock::SetFontStyle (FontStyles value)
{
	SetValue (TextBlock::FontStyleProperty, Value (value));
}

FontStretches
TextBlock::GetFontStretch ()
{
	Value *value = GetValue (TextBlock::FontStretchProperty);
	return (FontStretches) value->AsInt32 ();
}

void
TextBlock::SetFontStretch (FontStretches value)
{
	SetValue (TextBlock::FontStretchProperty, Value (value));
}

FontSource *
TextBlock::GetFontSource ()
{
	Value *value = GetValue (TextBlock::FontSourceProperty);
	return value ? value->AsFontSource () : NULL;
}

void
TextBlock::SetFontSource (FontSource *value)
{
	if (!value) return;
	SetValue (TextBlock::FontSourceProperty, Value (*value));
}

double
TextBlock::GetFontSize ()
{
	Value *value = GetValue (TextBlock::FontSizeProperty);
	return value->AsDouble ();
}

void
TextBlock::SetFontSize (double value)
{
	SetValue (TextBlock::FontSizeProperty, Value (value));
}

const char *
TextBlock::GetFontGUID ()
{
	Value *value = GetValue (TextBlock::FontGUIDProperty);
	return value ? value->AsString () : NULL;
}

void
TextBlock::SetFontGUID (const char *value)
{
	SetValue (TextBlock::FontGUIDProperty, Value (value));
}

const char *
TextBlock::GetFontFilename ()
{
	Value *value = GetValue (TextBlock::FontFilenameProperty);
	return value ? value->AsString () : NULL;
}

void
TextBlock::SetFontFilename (const char *value)
{
	SetValue (TextBlock::FontFilenameProperty, Value (value));
}

FontFamily *
TextBlock::GetFontFamily ()
{
	Value *value = GetValue (TextBlock::FontFamilyProperty);
	return value ? value->AsFontFamily () : NULL;
}

void
TextBlock::SetFontFamily (FontFamily *value)
{
	if (!value) return;
	SetValue (TextBlock::FontFamilyProperty, Value (*value));
}

double
Popup::GetVerticalOffset ()
{
	Value *value = GetValue (Popup::VerticalOffsetProperty);
	return value->AsDouble ();
}

void
Popup::SetVerticalOffset (double value)
{
	SetValue (Popup::VerticalOffsetProperty, Value (value));
}

bool
Popup::GetIsOpen ()
{
	Value *value = GetValue (Popup::IsOpenProperty);
	return value->AsBool ();
}

void
Popup::SetIsOpen (bool value)
{
	SetValue (Popup::IsOpenProperty, Value (value));
}

double
Popup::GetHorizontalOffset ()
{
	Value *value = GetValue (Popup::HorizontalOffsetProperty);
	return value->AsDouble ();
}

void
Popup::SetHorizontalOffset (double value)
{
	SetValue (Popup::HorizontalOffsetProperty, Value (value));
}

UIElement *
Popup::GetChild ()
{
	Value *value = GetValue (Popup::ChildProperty);
	return value ? value->AsUIElement () : NULL;
}

void
Popup::SetChild (UIElement *value)
{
	SetValue (Popup::ChildProperty, Value (value));
}

double
MediaElement::GetVolume ()
{
	Value *value = GetValue (MediaElement::VolumeProperty);
	return value->AsDouble ();
}

void
MediaElement::SetVolume (double value)
{
	SetValue (MediaElement::VolumeProperty, Value (value));
}

Stretch
MediaElement::GetStretch ()
{
	Value *value = GetValue (MediaElement::StretchProperty);
	return (Stretch) value->AsInt32 ();
}

void
MediaElement::SetStretch (Stretch value)
{
	SetValue (MediaElement::StretchProperty, Value (value));
}

Uri *
MediaElement::GetSource ()
{
	Value *value = GetValue (MediaElement::SourceProperty);
	return value ? value->AsUri () : NULL;
}

void
MediaElement::SetSource (Uri *value)
{
	if (!value) return;
	SetValue (MediaElement::SourceProperty, Value (*value));
}

double
MediaElement::GetRenderedFramesPerSecond ()
{
	Value *value = GetValue (MediaElement::RenderedFramesPerSecondProperty);
	return value->AsDouble ();
}

void
MediaElement::SetRenderedFramesPerSecond (double value)
{
	SetValue (MediaElement::RenderedFramesPerSecondProperty, Value (value));
}

TimeSpan
MediaElement::GetPosition ()
{
	Value *value = GetValue (MediaElement::PositionProperty);
	return value->AsTimeSpan ();
}

void
MediaElement::SetPosition (TimeSpan value)
{
	SetValue (MediaElement::PositionProperty, Value (value, Type::TIMESPAN));
}

gint32
MediaElement::GetNaturalVideoWidth ()
{
	Value *value = GetValue (MediaElement::NaturalVideoWidthProperty);
	return value->AsInt32 ();
}

void
MediaElement::SetNaturalVideoWidth (gint32 value)
{
	SetValue (MediaElement::NaturalVideoWidthProperty, Value (value));
}

gint32
MediaElement::GetNaturalVideoHeight ()
{
	Value *value = GetValue (MediaElement::NaturalVideoHeightProperty);
	return value->AsInt32 ();
}

void
MediaElement::SetNaturalVideoHeight (gint32 value)
{
	SetValue (MediaElement::NaturalVideoHeightProperty, Value (value));
}

Duration *
MediaElement::GetNaturalDuration ()
{
	Value *value = GetValue (MediaElement::NaturalDurationProperty);
	return value ? value->AsDuration () : NULL;
}

void
MediaElement::SetNaturalDuration (Duration *value)
{
	if (!value) return;
	SetValue (MediaElement::NaturalDurationProperty, Value (*value));
}

TimelineMarkerCollection *
MediaElement::GetMarkers ()
{
	Value *value = GetValue (MediaElement::MarkersProperty);
	return value ? value->AsTimelineMarkerCollection () : NULL;
}

void
MediaElement::SetMarkers (TimelineMarkerCollection *value)
{
	SetValue (MediaElement::MarkersProperty, Value (value));
}

bool
MediaElement::GetIsMuted ()
{
	Value *value = GetValue (MediaElement::IsMutedProperty);
	return value->AsBool ();
}

void
MediaElement::SetIsMuted (bool value)
{
	SetValue (MediaElement::IsMutedProperty, Value (value));
}

double
MediaElement::GetDroppedFramesPerSecond ()
{
	Value *value = GetValue (MediaElement::DroppedFramesPerSecondProperty);
	return value->AsDouble ();
}

void
MediaElement::SetDroppedFramesPerSecond (double value)
{
	SetValue (MediaElement::DroppedFramesPerSecondProperty, Value (value));
}

double
MediaElement::GetDownloadProgress ()
{
	Value *value = GetValue (MediaElement::DownloadProgressProperty);
	return value->AsDouble ();
}

void
MediaElement::SetDownloadProgress (double value)
{
	SetValue (MediaElement::DownloadProgressProperty, Value (value));
}

double
MediaElement::GetDownloadProgressOffset ()
{
	Value *value = GetValue (MediaElement::DownloadProgressOffsetProperty);
	return value->AsDouble ();
}

void
MediaElement::SetDownloadProgressOffset (double value)
{
	SetValue (MediaElement::DownloadProgressOffsetProperty, Value (value));
}

MediaState
MediaElement::GetCurrentState ()
{
	Value *value = GetValue (MediaElement::CurrentStateProperty);
	return (MediaState) value->AsInt32 ();
}

void
MediaElement::SetCurrentState (MediaState value)
{
	SetValue (MediaElement::CurrentStateProperty, Value (value));
}

bool
MediaElement::GetCanSeek ()
{
	Value *value = GetValue (MediaElement::CanSeekProperty);
	return value->AsBool ();
}

void
MediaElement::SetCanSeek (bool value)
{
	SetValue (MediaElement::CanSeekProperty, Value (value));
}

bool
MediaElement::GetCanPause ()
{
	Value *value = GetValue (MediaElement::CanPauseProperty);
	return value->AsBool ();
}

void
MediaElement::SetCanPause (bool value)
{
	SetValue (MediaElement::CanPauseProperty, Value (value));
}

TimeSpan
MediaElement::GetBufferingTime ()
{
	Value *value = GetValue (MediaElement::BufferingTimeProperty);
	return value->AsTimeSpan ();
}

void
MediaElement::SetBufferingTime (TimeSpan value)
{
	SetValue (MediaElement::BufferingTimeProperty, Value (value, Type::TIMESPAN));
}

double
MediaElement::GetBufferingProgress ()
{
	Value *value = GetValue (MediaElement::BufferingProgressProperty);
	return value->AsDouble ();
}

void
MediaElement::SetBufferingProgress (double value)
{
	SetValue (MediaElement::BufferingProgressProperty, Value (value));
}

double
MediaElement::GetBalance ()
{
	Value *value = GetValue (MediaElement::BalanceProperty);
	return value->AsDouble ();
}

void
MediaElement::SetBalance (double value)
{
	SetValue (MediaElement::BalanceProperty, Value (value));
}

bool
MediaElement::GetAutoPlay ()
{
	Value *value = GetValue (MediaElement::AutoPlayProperty);
	return value->AsBool ();
}

void
MediaElement::SetAutoPlay (bool value)
{
	SetValue (MediaElement::AutoPlayProperty, Value (value));
}

gint32 *
MediaElement::GetAudioStreamIndex ()
{
	Value *value = GetValue (MediaElement::AudioStreamIndexProperty);
	return value ? value->AsNullableInt32 () : NULL;
}

void
MediaElement::SetAudioStreamIndex (gint32 value)
{
	SetValue (MediaElement::AudioStreamIndexProperty, Value (value));
}

void
MediaElement::SetAudioStreamIndex (gint32 * value)
{
	if (!value)
		SetValue (MediaElement::AudioStreamIndexProperty, NULL);
	else
		SetValue (MediaElement::AudioStreamIndexProperty, Value (*value));
}

gint32
MediaElement::GetAudioStreamCount ()
{
	Value *value = GetValue (MediaElement::AudioStreamCountProperty);
	return value->AsInt32 ();
}

void
MediaElement::SetAudioStreamCount (gint32 value)
{
	SetValue (MediaElement::AudioStreamCountProperty, Value (value));
}

MediaAttributeCollection *
MediaElement::GetAttributes ()
{
	Value *value = GetValue (MediaElement::AttributesProperty);
	return value ? value->AsMediaAttributeCollection () : NULL;
}

void
MediaElement::SetAttributes (MediaAttributeCollection *value)
{
	SetValue (MediaElement::AttributesProperty, Value (value));
}

double
Shape::GetStrokeThickness ()
{
	Value *value = GetValue (Shape::StrokeThicknessProperty);
	return value->AsDouble ();
}

void
Shape::SetStrokeThickness (double value)
{
	SetValue (Shape::StrokeThicknessProperty, Value (value));
}

PenLineCap
Shape::GetStrokeStartLineCap ()
{
	Value *value = GetValue (Shape::StrokeStartLineCapProperty);
	return (PenLineCap) value->AsInt32 ();
}

void
Shape::SetStrokeStartLineCap (PenLineCap value)
{
	SetValue (Shape::StrokeStartLineCapProperty, Value (value));
}

Brush *
Shape::GetStroke ()
{
	Value *value = GetValue (Shape::StrokeProperty);
	return value ? value->AsBrush () : NULL;
}

void
Shape::SetStroke (Brush *value)
{
	SetValue (Shape::StrokeProperty, Value (value));
}

double
Shape::GetStrokeMiterLimit ()
{
	Value *value = GetValue (Shape::StrokeMiterLimitProperty);
	return value->AsDouble ();
}

void
Shape::SetStrokeMiterLimit (double value)
{
	SetValue (Shape::StrokeMiterLimitProperty, Value (value));
}

PenLineJoin
Shape::GetStrokeLineJoin ()
{
	Value *value = GetValue (Shape::StrokeLineJoinProperty);
	return (PenLineJoin) value->AsInt32 ();
}

void
Shape::SetStrokeLineJoin (PenLineJoin value)
{
	SetValue (Shape::StrokeLineJoinProperty, Value (value));
}

PenLineCap
Shape::GetStrokeEndLineCap ()
{
	Value *value = GetValue (Shape::StrokeEndLineCapProperty);
	return (PenLineCap) value->AsInt32 ();
}

void
Shape::SetStrokeEndLineCap (PenLineCap value)
{
	SetValue (Shape::StrokeEndLineCapProperty, Value (value));
}

double
Shape::GetStrokeDashOffset ()
{
	Value *value = GetValue (Shape::StrokeDashOffsetProperty);
	return value->AsDouble ();
}

void
Shape::SetStrokeDashOffset (double value)
{
	SetValue (Shape::StrokeDashOffsetProperty, Value (value));
}

PenLineCap
Shape::GetStrokeDashCap ()
{
	Value *value = GetValue (Shape::StrokeDashCapProperty);
	return (PenLineCap) value->AsInt32 ();
}

void
Shape::SetStrokeDashCap (PenLineCap value)
{
	SetValue (Shape::StrokeDashCapProperty, Value (value));
}

DoubleCollection *
Shape::GetStrokeDashArray ()
{
	Value *value = GetValue (Shape::StrokeDashArrayProperty);
	return value ? value->AsDoubleCollection () : NULL;
}

void
Shape::SetStrokeDashArray (DoubleCollection *value)
{
	SetValue (Shape::StrokeDashArrayProperty, Value (value));
}

Stretch
Shape::GetStretch ()
{
	Value *value = GetValue (Shape::StretchProperty);
	return (Stretch) value->AsInt32 ();
}

void
Shape::SetStretch (Stretch value)
{
	SetValue (Shape::StretchProperty, Value (value));
}

Brush *
Shape::GetFill ()
{
	Value *value = GetValue (Shape::FillProperty);
	return value ? value->AsBrush () : NULL;
}

void
Shape::SetFill (Brush *value)
{
	SetValue (Shape::FillProperty, Value (value));
}

Stretch
MediaBase::GetStretch ()
{
	Value *value = GetValue (MediaBase::StretchProperty);
	return (Stretch) value->AsInt32 ();
}

void
MediaBase::SetStretch (Stretch value)
{
	SetValue (MediaBase::StretchProperty, Value (value));
}

const char *
MediaBase::GetSource ()
{
	Value *value = GetValue (MediaBase::SourceProperty);
	return value ? value->AsString () : NULL;
}

void
MediaBase::SetSource (const char *value)
{
	SetValue (MediaBase::SourceProperty, Value (value));
}

double
MediaBase::GetDownloadProgress ()
{
	Value *value = GetValue (MediaBase::DownloadProgressProperty);
	return value->AsDouble ();
}

void
MediaBase::SetDownloadProgress (double value)
{
	SetValue (MediaBase::DownloadProgressProperty, Value (value));
}

const char *
Glyphs::GetUnicodeString ()
{
	Value *value = GetValue (Glyphs::UnicodeStringProperty);
	return value ? value->AsString () : NULL;
}

void
Glyphs::SetUnicodeString (const char *value)
{
	SetValue (Glyphs::UnicodeStringProperty, Value (value));
}

StyleSimulations
Glyphs::GetStyleSimulations ()
{
	Value *value = GetValue (Glyphs::StyleSimulationsProperty);
	return (StyleSimulations) value->AsInt32 ();
}

void
Glyphs::SetStyleSimulations (StyleSimulations value)
{
	SetValue (Glyphs::StyleSimulationsProperty, Value (value));
}

double
Glyphs::GetOriginY ()
{
	Value *value = GetValue (Glyphs::OriginYProperty);
	return value->AsDouble ();
}

void
Glyphs::SetOriginY (double value)
{
	SetValue (Glyphs::OriginYProperty, Value (value));
}

double
Glyphs::GetOriginX ()
{
	Value *value = GetValue (Glyphs::OriginXProperty);
	return value->AsDouble ();
}

void
Glyphs::SetOriginX (double value)
{
	SetValue (Glyphs::OriginXProperty, Value (value));
}

const char *
Glyphs::GetIndices ()
{
	Value *value = GetValue (Glyphs::IndicesProperty);
	return value ? value->AsString () : NULL;
}

void
Glyphs::SetIndices (const char *value)
{
	SetValue (Glyphs::IndicesProperty, Value (value));
}

Uri *
Glyphs::GetFontUri ()
{
	Value *value = GetValue (Glyphs::FontUriProperty);
	return value ? value->AsUri () : NULL;
}

void
Glyphs::SetFontUri (Uri *value)
{
	if (!value) return;
	SetValue (Glyphs::FontUriProperty, Value (*value));
}

double
Glyphs::GetFontRenderingEmSize ()
{
	Value *value = GetValue (Glyphs::FontRenderingEmSizeProperty);
	return value->AsDouble ();
}

void
Glyphs::SetFontRenderingEmSize (double value)
{
	SetValue (Glyphs::FontRenderingEmSizeProperty, Value (value));
}

Brush *
Glyphs::GetFill ()
{
	Value *value = GetValue (Glyphs::FillProperty);
	return value ? value->AsBrush () : NULL;
}

void
Glyphs::SetFill (Brush *value)
{
	SetValue (Glyphs::FillProperty, Value (value));
}

VerticalAlignment
Control::GetVerticalContentAlignment ()
{
	Value *value = GetValue (Control::VerticalContentAlignmentProperty);
	return (VerticalAlignment) value->AsInt32 ();
}

void
Control::SetVerticalContentAlignment (VerticalAlignment value)
{
	SetValue (Control::VerticalContentAlignmentProperty, Value (value));
}

ControlTemplate *
Control::GetTemplate ()
{
	Value *value = GetValue (Control::TemplateProperty);
	return value ? value->AsControlTemplate () : NULL;
}

void
Control::SetTemplate (ControlTemplate *value)
{
	SetValue (Control::TemplateProperty, Value (value));
}

KeyboardNavigationMode
Control::GetTabNavigation ()
{
	Value *value = GetValue (Control::TabNavigationProperty);
	return (KeyboardNavigationMode) value->AsInt32 ();
}

void
Control::SetTabNavigation (KeyboardNavigationMode value)
{
	SetValue (Control::TabNavigationProperty, Value (value));
}

gint32
Control::GetTabIndex ()
{
	Value *value = GetValue (Control::TabIndexProperty);
	return value->AsInt32 ();
}

void
Control::SetTabIndex (gint32 value)
{
	SetValue (Control::TabIndexProperty, Value (value));
}

Thickness *
Control::GetPadding ()
{
	Value *value = GetValue (Control::PaddingProperty);
	return value ? value->AsThickness () : NULL;
}

void
Control::SetPadding (Thickness *value)
{
	if (!value) return;
	SetValue (Control::PaddingProperty, Value (*value));
}

bool
Control::GetIsTabStop ()
{
	Value *value = GetValue (Control::IsTabStopProperty);
	return value->AsBool ();
}

void
Control::SetIsTabStop (bool value)
{
	SetValue (Control::IsTabStopProperty, Value (value));
}

HorizontalAlignment
Control::GetHorizontalContentAlignment ()
{
	Value *value = GetValue (Control::HorizontalContentAlignmentProperty);
	return (HorizontalAlignment) value->AsInt32 ();
}

void
Control::SetHorizontalContentAlignment (HorizontalAlignment value)
{
	SetValue (Control::HorizontalContentAlignmentProperty, Value (value));
}

Brush *
Control::GetForeground ()
{
	Value *value = GetValue (Control::ForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Control::SetForeground (Brush *value)
{
	SetValue (Control::ForegroundProperty, Value (value));
}

FontWeights
Control::GetFontWeight ()
{
	Value *value = GetValue (Control::FontWeightProperty);
	return (FontWeights) value->AsInt32 ();
}

void
Control::SetFontWeight (FontWeights value)
{
	SetValue (Control::FontWeightProperty, Value (value));
}

FontStyles
Control::GetFontStyle ()
{
	Value *value = GetValue (Control::FontStyleProperty);
	return (FontStyles) value->AsInt32 ();
}

void
Control::SetFontStyle (FontStyles value)
{
	SetValue (Control::FontStyleProperty, Value (value));
}

FontStretches
Control::GetFontStretch ()
{
	Value *value = GetValue (Control::FontStretchProperty);
	return (FontStretches) value->AsInt32 ();
}

void
Control::SetFontStretch (FontStretches value)
{
	SetValue (Control::FontStretchProperty, Value (value));
}

double
Control::GetFontSize ()
{
	Value *value = GetValue (Control::FontSizeProperty);
	return value->AsDouble ();
}

void
Control::SetFontSize (double value)
{
	SetValue (Control::FontSizeProperty, Value (value));
}

FontFamily *
Control::GetFontFamily ()
{
	Value *value = GetValue (Control::FontFamilyProperty);
	return value ? value->AsFontFamily () : NULL;
}

void
Control::SetFontFamily (FontFamily *value)
{
	if (!value) return;
	SetValue (Control::FontFamilyProperty, Value (*value));
}

ManagedTypeInfo *
Control::GetDefaultStyleKey ()
{
	Value *value = GetValue (Control::DefaultStyleKeyProperty);
	return value ? value->AsManagedTypeInfo () : NULL;
}

void
Control::SetDefaultStyleKey (ManagedTypeInfo *value)
{
	if (!value) return;
	SetValue (Control::DefaultStyleKeyProperty, Value (*value));
}

Thickness *
Control::GetBorderThickness ()
{
	Value *value = GetValue (Control::BorderThicknessProperty);
	return value ? value->AsThickness () : NULL;
}

void
Control::SetBorderThickness (Thickness *value)
{
	if (!value) return;
	SetValue (Control::BorderThicknessProperty, Value (*value));
}

Brush *
Control::GetBorderBrush ()
{
	Value *value = GetValue (Control::BorderBrushProperty);
	return value ? value->AsBrush () : NULL;
}

void
Control::SetBorderBrush (Brush *value)
{
	SetValue (Control::BorderBrushProperty, Value (value));
}

Brush *
Control::GetBackground ()
{
	Value *value = GetValue (Control::BackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Control::SetBackground (Brush *value)
{
	SetValue (Control::BackgroundProperty, Value (value));
}

UIElementCollection *
Panel::GetChildren ()
{
	Value *value = GetValue (Panel::ChildrenProperty);
	return value ? value->AsUIElementCollection () : NULL;
}

void
Panel::SetChildren (UIElementCollection *value)
{
	SetValue (Panel::ChildrenProperty, Value (value));
}

Brush *
Panel::GetBackground ()
{
	Value *value = GetValue (Panel::BackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Panel::SetBackground (Brush *value)
{
	SetValue (Panel::BackgroundProperty, Value (value));
}

Thickness *
Border::GetPadding ()
{
	Value *value = GetValue (Border::PaddingProperty);
	return value ? value->AsThickness () : NULL;
}

void
Border::SetPadding (Thickness *value)
{
	if (!value) return;
	SetValue (Border::PaddingProperty, Value (*value));
}

CornerRadius *
Border::GetCornerRadius ()
{
	Value *value = GetValue (Border::CornerRadiusProperty);
	return value ? value->AsCornerRadius () : NULL;
}

void
Border::SetCornerRadius (CornerRadius *value)
{
	if (!value) return;
	SetValue (Border::CornerRadiusProperty, Value (*value));
}

UIElement *
Border::GetChild ()
{
	Value *value = GetValue (Border::ChildProperty);
	return value ? value->AsUIElement () : NULL;
}

void
Border::SetChild (UIElement *value)
{
	SetValue (Border::ChildProperty, Value (value));
}

Thickness *
Border::GetBorderThickness ()
{
	Value *value = GetValue (Border::BorderThicknessProperty);
	return value ? value->AsThickness () : NULL;
}

void
Border::SetBorderThickness (Thickness *value)
{
	if (!value) return;
	SetValue (Border::BorderThicknessProperty, Value (*value));
}

Brush *
Border::GetBorderBrush ()
{
	Value *value = GetValue (Border::BorderBrushProperty);
	return value ? value->AsBrush () : NULL;
}

void
Border::SetBorderBrush (Brush *value)
{
	SetValue (Border::BorderBrushProperty, Value (value));
}

Brush *
Border::GetBackground ()
{
	Value *value = GetValue (Border::BackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Border::SetBackground (Brush *value)
{
	SetValue (Border::BackgroundProperty, Value (value));
}

TimelineCollection *
TimelineGroup::GetChildren ()
{
	Value *value = GetValue (TimelineGroup::ChildrenProperty);
	return value ? value->AsTimelineCollection () : NULL;
}

void
TimelineGroup::SetChildren (TimelineCollection *value)
{
	SetValue (TimelineGroup::ChildrenProperty, Value (value));
}

const char *
Run::GetText ()
{
	Value *value = GetValue (Run::TextProperty);
	return value ? value->AsString () : NULL;
}

void
Run::SetText (const char *value)
{
	SetValue (Run::TextProperty, Value (value));
}

Rect *
RectangleGeometry::GetRect ()
{
	Value *value = GetValue (RectangleGeometry::RectProperty);
	return value ? value->AsRect () : NULL;
}

void
RectangleGeometry::SetRect (Rect *value)
{
	if (!value) return;
	SetValue (RectangleGeometry::RectProperty, Value (*value));
}

double
RectangleGeometry::GetRadiusY ()
{
	Value *value = GetValue (RectangleGeometry::RadiusYProperty);
	return value->AsDouble ();
}

void
RectangleGeometry::SetRadiusY (double value)
{
	SetValue (RectangleGeometry::RadiusYProperty, Value (value));
}

double
RectangleGeometry::GetRadiusX ()
{
	Value *value = GetValue (RectangleGeometry::RadiusXProperty);
	return value->AsDouble ();
}

void
RectangleGeometry::SetRadiusX (double value)
{
	SetValue (RectangleGeometry::RadiusXProperty, Value (value));
}

FillRule
PathGeometry::GetFillRule ()
{
	Value *value = GetValue (PathGeometry::FillRuleProperty);
	return (FillRule) value->AsInt32 ();
}

void
PathGeometry::SetFillRule (FillRule value)
{
	SetValue (PathGeometry::FillRuleProperty, Value (value));
}

PathFigureCollection *
PathGeometry::GetFigures ()
{
	Value *value = GetValue (PathGeometry::FiguresProperty);
	return value ? value->AsPathFigureCollection () : NULL;
}

void
PathGeometry::SetFigures (PathFigureCollection *value)
{
	SetValue (PathGeometry::FiguresProperty, Value (value));
}

Point *
LineGeometry::GetStartPoint ()
{
	Value *value = GetValue (LineGeometry::StartPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LineGeometry::SetStartPoint (Point *value)
{
	if (!value) return;
	SetValue (LineGeometry::StartPointProperty, Value (*value));
}

Point *
LineGeometry::GetEndPoint ()
{
	Value *value = GetValue (LineGeometry::EndPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LineGeometry::SetEndPoint (Point *value)
{
	if (!value) return;
	SetValue (LineGeometry::EndPointProperty, Value (*value));
}

FillRule
GeometryGroup::GetFillRule ()
{
	Value *value = GetValue (GeometryGroup::FillRuleProperty);
	return (FillRule) value->AsInt32 ();
}

void
GeometryGroup::SetFillRule (FillRule value)
{
	SetValue (GeometryGroup::FillRuleProperty, Value (value));
}

GeometryCollection *
GeometryGroup::GetChildren ()
{
	Value *value = GetValue (GeometryGroup::ChildrenProperty);
	return value ? value->AsGeometryCollection () : NULL;
}

void
GeometryGroup::SetChildren (GeometryCollection *value)
{
	SetValue (GeometryGroup::ChildrenProperty, Value (value));
}

double
EllipseGeometry::GetRadiusY ()
{
	Value *value = GetValue (EllipseGeometry::RadiusYProperty);
	return value->AsDouble ();
}

void
EllipseGeometry::SetRadiusY (double value)
{
	SetValue (EllipseGeometry::RadiusYProperty, Value (value));
}

double
EllipseGeometry::GetRadiusX ()
{
	Value *value = GetValue (EllipseGeometry::RadiusXProperty);
	return value->AsDouble ();
}

void
EllipseGeometry::SetRadiusX (double value)
{
	SetValue (EllipseGeometry::RadiusXProperty, Value (value));
}

Point *
EllipseGeometry::GetCenter ()
{
	Value *value = GetValue (EllipseGeometry::CenterProperty);
	return value ? value->AsPoint () : NULL;
}

void
EllipseGeometry::SetCenter (Point *value)
{
	if (!value) return;
	SetValue (EllipseGeometry::CenterProperty, Value (*value));
}

double
FrameworkElement::GetWidth ()
{
	Value *value = GetValue (FrameworkElement::WidthProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetWidth (double value)
{
	SetValue (FrameworkElement::WidthProperty, Value (value));
}

VerticalAlignment
FrameworkElement::GetVerticalAlignment ()
{
	Value *value = GetValue (FrameworkElement::VerticalAlignmentProperty);
	return (VerticalAlignment) value->AsInt32 ();
}

void
FrameworkElement::SetVerticalAlignment (VerticalAlignment value)
{
	SetValue (FrameworkElement::VerticalAlignmentProperty, Value (value));
}

Style *
FrameworkElement::GetStyle ()
{
	Value *value = GetValue (FrameworkElement::StyleProperty);
	return value ? value->AsStyle () : NULL;
}

void
FrameworkElement::SetStyle (Style *value)
{
	SetValue (FrameworkElement::StyleProperty, Value (value));
}

double
FrameworkElement::GetMinWidth ()
{
	Value *value = GetValue (FrameworkElement::MinWidthProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetMinWidth (double value)
{
	SetValue (FrameworkElement::MinWidthProperty, Value (value));
}

double
FrameworkElement::GetMinHeight ()
{
	Value *value = GetValue (FrameworkElement::MinHeightProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetMinHeight (double value)
{
	SetValue (FrameworkElement::MinHeightProperty, Value (value));
}

double
FrameworkElement::GetMaxWidth ()
{
	Value *value = GetValue (FrameworkElement::MaxWidthProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetMaxWidth (double value)
{
	SetValue (FrameworkElement::MaxWidthProperty, Value (value));
}

double
FrameworkElement::GetMaxHeight ()
{
	Value *value = GetValue (FrameworkElement::MaxHeightProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetMaxHeight (double value)
{
	SetValue (FrameworkElement::MaxHeightProperty, Value (value));
}

Thickness *
FrameworkElement::GetMargin ()
{
	Value *value = GetValue (FrameworkElement::MarginProperty);
	return value ? value->AsThickness () : NULL;
}

void
FrameworkElement::SetMargin (Thickness *value)
{
	if (!value) return;
	SetValue (FrameworkElement::MarginProperty, Value (*value));
}

HorizontalAlignment
FrameworkElement::GetHorizontalAlignment ()
{
	Value *value = GetValue (FrameworkElement::HorizontalAlignmentProperty);
	return (HorizontalAlignment) value->AsInt32 ();
}

void
FrameworkElement::SetHorizontalAlignment (HorizontalAlignment value)
{
	SetValue (FrameworkElement::HorizontalAlignmentProperty, Value (value));
}

double
FrameworkElement::GetHeight ()
{
	Value *value = GetValue (FrameworkElement::HeightProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetHeight (double value)
{
	SetValue (FrameworkElement::HeightProperty, Value (value));
}

double
FrameworkElement::GetActualWidth ()
{
	Value *value = GetValue (FrameworkElement::ActualWidthProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetActualWidth (double value)
{
	SetValue (FrameworkElement::ActualWidthProperty, Value (value));
}

double
FrameworkElement::GetActualHeight ()
{
	Value *value = GetValue (FrameworkElement::ActualHeightProperty);
	return value->AsDouble ();
}

void
FrameworkElement::SetActualHeight (double value)
{
	SetValue (FrameworkElement::ActualHeightProperty, Value (value));
}

double
PowerEase::GetPower ()
{
	Value *value = GetValue (PowerEase::PowerProperty);
	return value->AsDouble ();
}

void
PowerEase::SetPower (double value)
{
	SetValue (PowerEase::PowerProperty, Value (value));
}

double
ExponentialEase::GetExponent ()
{
	Value *value = GetValue (ExponentialEase::ExponentProperty);
	return value->AsDouble ();
}

void
ExponentialEase::SetExponent (double value)
{
	SetValue (ExponentialEase::ExponentProperty, Value (value));
}

double
ElasticEase::GetSpringiness ()
{
	Value *value = GetValue (ElasticEase::SpringinessProperty);
	return value->AsDouble ();
}

void
ElasticEase::SetSpringiness (double value)
{
	SetValue (ElasticEase::SpringinessProperty, Value (value));
}

gint32
ElasticEase::GetOscillations ()
{
	Value *value = GetValue (ElasticEase::OscillationsProperty);
	return value->AsInt32 ();
}

void
ElasticEase::SetOscillations (gint32 value)
{
	SetValue (ElasticEase::OscillationsProperty, Value (value));
}

double
BounceEase::GetBounciness ()
{
	Value *value = GetValue (BounceEase::BouncinessProperty);
	return value->AsDouble ();
}

void
BounceEase::SetBounciness (double value)
{
	SetValue (BounceEase::BouncinessProperty, Value (value));
}

gint32
BounceEase::GetBounces ()
{
	Value *value = GetValue (BounceEase::BouncesProperty);
	return value->AsInt32 ();
}

void
BounceEase::SetBounces (gint32 value)
{
	SetValue (BounceEase::BouncesProperty, Value (value));
}

double
BackEase::GetAmplitude ()
{
	Value *value = GetValue (BackEase::AmplitudeProperty);
	return value->AsDouble ();
}

void
BackEase::SetAmplitude (double value)
{
	SetValue (BackEase::AmplitudeProperty, Value (value));
}

KeySpline *
SplinePointKeyFrame::GetKeySpline ()
{
	Value *value = DependencyObject::GetValue (SplinePointKeyFrame::KeySplineProperty);
	return value ? value->AsKeySpline () : NULL;
}

void
SplinePointKeyFrame::SetKeySpline (KeySpline *value)
{
	DependencyObject::SetValue (SplinePointKeyFrame::KeySplineProperty, Value (value));
}

EasingFunctionBase *
EasingPointKeyFrame::GetEasingFunction ()
{
	Value *value = DependencyObject::GetValue (EasingPointKeyFrame::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
EasingPointKeyFrame::SetEasingFunction (EasingFunctionBase *value)
{
	DependencyObject::SetValue (EasingPointKeyFrame::EasingFunctionProperty, Value (value));
}

PointKeyFrameCollection *
PointAnimationUsingKeyFrames::GetKeyFrames ()
{
	Value *value = GetValue (PointAnimationUsingKeyFrames::KeyFramesProperty);
	return value ? value->AsPointKeyFrameCollection () : NULL;
}

void
PointAnimationUsingKeyFrames::SetKeyFrames (PointKeyFrameCollection *value)
{
	SetValue (PointAnimationUsingKeyFrames::KeyFramesProperty, Value (value));
}

KeySpline *
SplineDoubleKeyFrame::GetKeySpline ()
{
	Value *value = DependencyObject::GetValue (SplineDoubleKeyFrame::KeySplineProperty);
	return value ? value->AsKeySpline () : NULL;
}

void
SplineDoubleKeyFrame::SetKeySpline (KeySpline *value)
{
	DependencyObject::SetValue (SplineDoubleKeyFrame::KeySplineProperty, Value (value));
}

EasingFunctionBase *
EasingDoubleKeyFrame::GetEasingFunction ()
{
	Value *value = DependencyObject::GetValue (EasingDoubleKeyFrame::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
EasingDoubleKeyFrame::SetEasingFunction (EasingFunctionBase *value)
{
	DependencyObject::SetValue (EasingDoubleKeyFrame::EasingFunctionProperty, Value (value));
}

DoubleKeyFrameCollection *
DoubleAnimationUsingKeyFrames::GetKeyFrames ()
{
	Value *value = GetValue (DoubleAnimationUsingKeyFrames::KeyFramesProperty);
	return value ? value->AsDoubleKeyFrameCollection () : NULL;
}

void
DoubleAnimationUsingKeyFrames::SetKeyFrames (DoubleKeyFrameCollection *value)
{
	SetValue (DoubleAnimationUsingKeyFrames::KeyFramesProperty, Value (value));
}

const char *
TimelineMarker::GetType ()
{
	Value *value = GetValue (TimelineMarker::TypeProperty);
	return value ? value->AsString () : NULL;
}

void
TimelineMarker::SetType (const char *value)
{
	SetValue (TimelineMarker::TypeProperty, Value (value));
}

TimeSpan
TimelineMarker::GetTime ()
{
	Value *value = GetValue (TimelineMarker::TimeProperty);
	return value->AsTimeSpan ();
}

void
TimelineMarker::SetTime (TimeSpan value)
{
	SetValue (TimelineMarker::TimeProperty, Value (value, Type::TIMESPAN));
}

const char *
TimelineMarker::GetText ()
{
	Value *value = GetValue (TimelineMarker::TextProperty);
	return value ? value->AsString () : NULL;
}

void
TimelineMarker::SetText (const char *value)
{
	SetValue (TimelineMarker::TextProperty, Value (value));
}

double
Timeline::GetSpeedRatio ()
{
	Value *value = GetValue (Timeline::SpeedRatioProperty);
	return value->AsDouble ();
}

void
Timeline::SetSpeedRatio (double value)
{
	SetValue (Timeline::SpeedRatioProperty, Value (value));
}

FillBehavior
Timeline::GetFillBehavior ()
{
	Value *value = GetValue (Timeline::FillBehaviorProperty);
	return (FillBehavior) value->AsInt32 ();
}

void
Timeline::SetFillBehavior (FillBehavior value)
{
	SetValue (Timeline::FillBehaviorProperty, Value (value));
}

bool
Timeline::GetAutoReverse ()
{
	Value *value = GetValue (Timeline::AutoReverseProperty);
	return value->AsBool ();
}

void
Timeline::SetAutoReverse (bool value)
{
	SetValue (Timeline::AutoReverseProperty, Value (value));
}

double
StylusPoint::GetY ()
{
	Value *value = GetValue (StylusPoint::YProperty);
	return value->AsDouble ();
}

void
StylusPoint::SetY (double value)
{
	SetValue (StylusPoint::YProperty, Value (value));
}

double
StylusPoint::GetX ()
{
	Value *value = GetValue (StylusPoint::XProperty);
	return value->AsDouble ();
}

void
StylusPoint::SetX (double value)
{
	SetValue (StylusPoint::XProperty, Value (value));
}

double
StylusPoint::GetPressureFactor ()
{
	Value *value = GetValue (StylusPoint::PressureFactorProperty);
	return value->AsDouble ();
}

void
StylusPoint::SetPressureFactor (double value)
{
	SetValue (StylusPoint::PressureFactorProperty, Value (value));
}

bool
StylusInfo::GetIsInverted ()
{
	Value *value = GetValue (StylusInfo::IsInvertedProperty);
	return value->AsBool ();
}

void
StylusInfo::SetIsInverted (bool value)
{
	SetValue (StylusInfo::IsInvertedProperty, Value (value));
}

TabletDeviceType
StylusInfo::GetDeviceType ()
{
	Value *value = GetValue (StylusInfo::DeviceTypeProperty);
	return (TabletDeviceType) value->AsInt32 ();
}

void
StylusInfo::SetDeviceType (TabletDeviceType value)
{
	SetValue (StylusInfo::DeviceTypeProperty, Value (value));
}

SetterBaseCollection *
Style::GetSetters ()
{
	Value *value = GetValue (Style::SettersProperty);
	return value ? value->AsSetterBaseCollection () : NULL;
}

void
Style::SetSetters (SetterBaseCollection *value)
{
	SetValue (Style::SettersProperty, Value (value));
}

bool
Style::GetIsSealed ()
{
	Value *value = GetValue (Style::IsSealedProperty);
	return value->AsBool ();
}

void
Style::SetIsSealed (bool value)
{
	SetValue (Style::IsSealedProperty, Value (value));
}

StylusPointCollection *
Stroke::GetStylusPoints ()
{
	Value *value = GetValue (Stroke::StylusPointsProperty);
	return value ? value->AsStylusPointCollection () : NULL;
}

void
Stroke::SetStylusPoints (StylusPointCollection *value)
{
	SetValue (Stroke::StylusPointsProperty, Value (value));
}

DrawingAttributes *
Stroke::GetDrawingAttributes ()
{
	Value *value = GetValue (Stroke::DrawingAttributesProperty);
	return value ? value->AsDrawingAttributes () : NULL;
}

void
Stroke::SetDrawingAttributes (DrawingAttributes *value)
{
	SetValue (Stroke::DrawingAttributesProperty, Value (value));
}

bool
SetterBase::GetIsSealed ()
{
	Value *value = GetValue (SetterBase::IsSealedProperty);
	return value->AsBool ();
}

void
SetterBase::SetIsSealed (bool value)
{
	SetValue (SetterBase::IsSealedProperty, Value (value));
}

double
RowDefinition::GetMinHeight ()
{
	Value *value = GetValue (RowDefinition::MinHeightProperty);
	return value->AsDouble ();
}

void
RowDefinition::SetMinHeight (double value)
{
	SetValue (RowDefinition::MinHeightProperty, Value (value));
}

double
RowDefinition::GetMaxHeight ()
{
	Value *value = GetValue (RowDefinition::MaxHeightProperty);
	return value->AsDouble ();
}

void
RowDefinition::SetMaxHeight (double value)
{
	SetValue (RowDefinition::MaxHeightProperty, Value (value));
}

GridLength *
RowDefinition::GetHeight ()
{
	Value *value = GetValue (RowDefinition::HeightProperty);
	return value ? value->AsGridLength () : NULL;
}

void
RowDefinition::SetHeight (GridLength *value)
{
	if (!value) return;
	SetValue (RowDefinition::HeightProperty, Value (*value));
}

Point *
PathFigure::GetStartPoint ()
{
	Value *value = GetValue (PathFigure::StartPointProperty);
	return value ? value->AsPoint () : NULL;
}

void
PathFigure::SetStartPoint (Point *value)
{
	if (!value) return;
	SetValue (PathFigure::StartPointProperty, Value (*value));
}

PathSegmentCollection *
PathFigure::GetSegments ()
{
	Value *value = GetValue (PathFigure::SegmentsProperty);
	return value ? value->AsPathSegmentCollection () : NULL;
}

void
PathFigure::SetSegments (PathSegmentCollection *value)
{
	SetValue (PathFigure::SegmentsProperty, Value (value));
}

bool
PathFigure::GetIsFilled ()
{
	Value *value = GetValue (PathFigure::IsFilledProperty);
	return value->AsBool ();
}

void
PathFigure::SetIsFilled (bool value)
{
	SetValue (PathFigure::IsFilledProperty, Value (value));
}

bool
PathFigure::GetIsClosed ()
{
	Value *value = GetValue (PathFigure::IsClosedProperty);
	return value->AsBool ();
}

void
PathFigure::SetIsClosed (bool value)
{
	SetValue (PathFigure::IsClosedProperty, Value (value));
}

NameScope *
NameScope::GetNameScope (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (NameScope::NameScopeProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (NameScope::NameScopeProperty)->GetDefaultValue();
	return value ? value->AsNameScope () : NULL;
}

void
NameScope::SetNameScope (DependencyObject *obj, NameScope *value)
{
	if (!obj) return;
	obj->SetValue (NameScope::NameScopeProperty, Value (value));
}

gint32
MultiScaleSubImage::GetZIndex ()
{
	Value *value = GetValue (MultiScaleSubImage::ZIndexProperty);
	return value->AsInt32 ();
}

void
MultiScaleSubImage::SetZIndex (gint32 value)
{
	SetValue (MultiScaleSubImage::ZIndexProperty, Value (value));
}

double
MultiScaleSubImage::GetViewportWidth ()
{
	Value *value = GetValue (MultiScaleSubImage::ViewportWidthProperty);
	return value->AsDouble ();
}

void
MultiScaleSubImage::SetViewportWidth (double value)
{
	SetValue (MultiScaleSubImage::ViewportWidthProperty, Value (value));
}

Point *
MultiScaleSubImage::GetViewportOrigin ()
{
	Value *value = GetValue (MultiScaleSubImage::ViewportOriginProperty);
	return value ? value->AsPoint () : NULL;
}

void
MultiScaleSubImage::SetViewportOrigin (Point *value)
{
	if (!value) return;
	SetValue (MultiScaleSubImage::ViewportOriginProperty, Value (*value));
}

double
MultiScaleSubImage::GetOpacity ()
{
	Value *value = GetValue (MultiScaleSubImage::OpacityProperty);
	return value->AsDouble ();
}

void
MultiScaleSubImage::SetOpacity (double value)
{
	SetValue (MultiScaleSubImage::OpacityProperty, Value (value));
}

double
MultiScaleSubImage::GetAspectRatio ()
{
	Value *value = GetValue (MultiScaleSubImage::AspectRatioProperty);
	return value->AsDouble ();
}

const char *
MediaAttribute::GetValue ()
{
	Value *value = DependencyObject::GetValue (MediaAttribute::ValueProperty);
	return value ? value->AsString () : NULL;
}

void
MediaAttribute::SetValue (const char *value)
{
	DependencyObject::SetValue (MediaAttribute::ValueProperty, Value (value));
}

double
Matrix::GetOffsetY ()
{
	Value *value = GetValue (Matrix::OffsetYProperty);
	return value->AsDouble ();
}

void
Matrix::SetOffsetY (double value)
{
	SetValue (Matrix::OffsetYProperty, Value (value));
}

double
Matrix::GetOffsetX ()
{
	Value *value = GetValue (Matrix::OffsetXProperty);
	return value->AsDouble ();
}

void
Matrix::SetOffsetX (double value)
{
	SetValue (Matrix::OffsetXProperty, Value (value));
}

double
Matrix::GetM22 ()
{
	Value *value = GetValue (Matrix::M22Property);
	return value->AsDouble ();
}

void
Matrix::SetM22 (double value)
{
	SetValue (Matrix::M22Property, Value (value));
}

double
Matrix::GetM21 ()
{
	Value *value = GetValue (Matrix::M21Property);
	return value->AsDouble ();
}

void
Matrix::SetM21 (double value)
{
	SetValue (Matrix::M21Property, Value (value));
}

double
Matrix::GetM12 ()
{
	Value *value = GetValue (Matrix::M12Property);
	return value->AsDouble ();
}

void
Matrix::SetM12 (double value)
{
	SetValue (Matrix::M12Property, Value (value));
}

double
Matrix::GetM11 ()
{
	Value *value = GetValue (Matrix::M11Property);
	return value->AsDouble ();
}

void
Matrix::SetM11 (double value)
{
	SetValue (Matrix::M11Property, Value (value));
}

Point *
KeySpline::GetControlPoint2 ()
{
	Value *value = GetValue (KeySpline::ControlPoint2Property);
	return value ? value->AsPoint () : NULL;
}

void
KeySpline::SetControlPoint2 (Point *value)
{
	if (!value) return;
	SetValue (KeySpline::ControlPoint2Property, Value (*value));
}

Point *
KeySpline::GetControlPoint1 ()
{
	Value *value = GetValue (KeySpline::ControlPoint1Property);
	return value ? value->AsPoint () : NULL;
}

void
KeySpline::SetControlPoint1 (Point *value)
{
	if (!value) return;
	SetValue (KeySpline::ControlPoint1Property, Value (*value));
}

TextDecorations
Inline::GetTextDecorations ()
{
	Value *value = GetValue (Inline::TextDecorationsProperty);
	return (TextDecorations) value->AsInt32 ();
}

void
Inline::SetTextDecorations (TextDecorations value)
{
	SetValue (Inline::TextDecorationsProperty, Value (value));
}

Brush *
Inline::GetForeground ()
{
	Value *value = GetValue (Inline::ForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
Inline::SetForeground (Brush *value)
{
	SetValue (Inline::ForegroundProperty, Value (value));
}

FontWeights
Inline::GetFontWeight ()
{
	Value *value = GetValue (Inline::FontWeightProperty);
	return (FontWeights) value->AsInt32 ();
}

void
Inline::SetFontWeight (FontWeights value)
{
	SetValue (Inline::FontWeightProperty, Value (value));
}

FontStyles
Inline::GetFontStyle ()
{
	Value *value = GetValue (Inline::FontStyleProperty);
	return (FontStyles) value->AsInt32 ();
}

void
Inline::SetFontStyle (FontStyles value)
{
	SetValue (Inline::FontStyleProperty, Value (value));
}

FontStretches
Inline::GetFontStretch ()
{
	Value *value = GetValue (Inline::FontStretchProperty);
	return (FontStretches) value->AsInt32 ();
}

void
Inline::SetFontStretch (FontStretches value)
{
	SetValue (Inline::FontStretchProperty, Value (value));
}

FontSource *
Inline::GetFontSource ()
{
	Value *value = GetValue (Inline::FontSourceProperty);
	return value ? value->AsFontSource () : NULL;
}

void
Inline::SetFontSource (FontSource *value)
{
	if (!value) return;
	SetValue (Inline::FontSourceProperty, Value (*value));
}

double
Inline::GetFontSize ()
{
	Value *value = GetValue (Inline::FontSizeProperty);
	return value->AsDouble ();
}

void
Inline::SetFontSize (double value)
{
	SetValue (Inline::FontSizeProperty, Value (value));
}

const char *
Inline::GetFontGUID ()
{
	Value *value = GetValue (Inline::FontGUIDProperty);
	return value ? value->AsString () : NULL;
}

void
Inline::SetFontGUID (const char *value)
{
	SetValue (Inline::FontGUIDProperty, Value (value));
}

const char *
Inline::GetFontFilename ()
{
	Value *value = GetValue (Inline::FontFilenameProperty);
	return value ? value->AsString () : NULL;
}

void
Inline::SetFontFilename (const char *value)
{
	SetValue (Inline::FontFilenameProperty, Value (value));
}

FontFamily *
Inline::GetFontFamily ()
{
	Value *value = GetValue (Inline::FontFamilyProperty);
	return value ? value->AsFontFamily () : NULL;
}

void
Inline::SetFontFamily (FontFamily *value)
{
	if (!value) return;
	SetValue (Inline::FontFamilyProperty, Value (*value));
}

double
GradientStop::GetOffset ()
{
	Value *value = GetValue (GradientStop::OffsetProperty);
	return value->AsDouble ();
}

void
GradientStop::SetOffset (double value)
{
	SetValue (GradientStop::OffsetProperty, Value (value));
}

Color *
GradientStop::GetColor ()
{
	Value *value = GetValue (GradientStop::ColorProperty);
	return value ? value->AsColor () : NULL;
}

void
GradientStop::SetColor (Color *value)
{
	if (!value) return;
	SetValue (GradientStop::ColorProperty, Value (*value));
}

Transform *
Geometry::GetTransform ()
{
	Value *value = GetValue (Geometry::TransformProperty);
	return value ? value->AsTransform () : NULL;
}

void
Geometry::SetTransform (Transform *value)
{
	SetValue (Geometry::TransformProperty, Value (value));
}

double
DrawingAttributes::GetWidth ()
{
	Value *value = GetValue (DrawingAttributes::WidthProperty);
	return value->AsDouble ();
}

void
DrawingAttributes::SetWidth (double value)
{
	SetValue (DrawingAttributes::WidthProperty, Value (value));
}

Color *
DrawingAttributes::GetOutlineColor ()
{
	Value *value = GetValue (DrawingAttributes::OutlineColorProperty);
	return value ? value->AsColor () : NULL;
}

void
DrawingAttributes::SetOutlineColor (Color *value)
{
	if (!value) return;
	SetValue (DrawingAttributes::OutlineColorProperty, Value (*value));
}

double
DrawingAttributes::GetHeight ()
{
	Value *value = GetValue (DrawingAttributes::HeightProperty);
	return value->AsDouble ();
}

void
DrawingAttributes::SetHeight (double value)
{
	SetValue (DrawingAttributes::HeightProperty, Value (value));
}

Color *
DrawingAttributes::GetColor ()
{
	Value *value = GetValue (DrawingAttributes::ColorProperty);
	return value ? value->AsColor () : NULL;
}

void
DrawingAttributes::SetColor (Color *value)
{
	if (!value) return;
	SetValue (DrawingAttributes::ColorProperty, Value (*value));
}

Uri *
Downloader::GetUri ()
{
	Value *value = GetValue (Downloader::UriProperty);
	return value ? value->AsUri () : NULL;
}

void
Downloader::SetUri (Uri *value)
{
	if (!value) return;
	SetValue (Downloader::UriProperty, Value (*value));
}

const char *
Downloader::GetStatusText ()
{
	Value *value = GetValue (Downloader::StatusTextProperty);
	return value ? value->AsString () : NULL;
}

void
Downloader::SetStatusText (const char *value)
{
	SetValue (Downloader::StatusTextProperty, Value (value));
}

gint32
Downloader::GetStatus ()
{
	Value *value = GetValue (Downloader::StatusProperty);
	return value->AsInt32 ();
}

void
Downloader::SetStatus (gint32 value)
{
	SetValue (Downloader::StatusProperty, Value (value));
}

double
Downloader::GetDownloadProgress ()
{
	Value *value = GetValue (Downloader::DownloadProgressProperty);
	return value->AsDouble ();
}

void
Downloader::SetDownloadProgress (double value)
{
	SetValue (Downloader::DownloadProgressProperty, Value (value));
}

Surface *
Deployment::GetSurface ()
{
	Value *value = GetValue (Deployment::SurfaceProperty);
	return value ? value->AsSurface () : NULL;
}

void
Deployment::SetSurface (Surface *value)
{
	SetValue (Deployment::SurfaceProperty, Value (value));
}

GridLength *
ColumnDefinition::GetWidth ()
{
	Value *value = GetValue (ColumnDefinition::WidthProperty);
	return value ? value->AsGridLength () : NULL;
}

void
ColumnDefinition::SetWidth (GridLength *value)
{
	if (!value) return;
	SetValue (ColumnDefinition::WidthProperty, Value (*value));
}

double
ColumnDefinition::GetMinWidth ()
{
	Value *value = GetValue (ColumnDefinition::MinWidthProperty);
	return value->AsDouble ();
}

void
ColumnDefinition::SetMinWidth (double value)
{
	SetValue (ColumnDefinition::MinWidthProperty, Value (value));
}

double
ColumnDefinition::GetMaxWidth ()
{
	Value *value = GetValue (ColumnDefinition::MaxWidthProperty);
	return value->AsDouble ();
}

void
ColumnDefinition::SetMaxWidth (double value)
{
	SetValue (ColumnDefinition::MaxWidthProperty, Value (value));
}

gint32
Collection::GetCount ()
{
	Value *value = GetValue (Collection::CountProperty);
	return value->AsInt32 ();
}

void
Collection::SetCount (gint32 value)
{
	SetValue (Collection::CountProperty, Value (value));
}

Visibility
UIElement::GetVisibility ()
{
	Value *value = GetValue (UIElement::VisibilityProperty);
	return (Visibility) value->AsInt32 ();
}

void
UIElement::SetVisibility (Visibility value)
{
	SetValue (UIElement::VisibilityProperty, Value (value));
}

bool
UIElement::GetUseLayoutRounding ()
{
	Value *value = GetValue (UIElement::UseLayoutRoundingProperty);
	return value->AsBool ();
}

void
UIElement::SetUseLayoutRounding (bool value)
{
	SetValue (UIElement::UseLayoutRoundingProperty, Value (value));
}

TriggerCollection *
UIElement::GetTriggers ()
{
	Value *value = GetValue (UIElement::TriggersProperty);
	return value ? value->AsTriggerCollection () : NULL;
}

void
UIElement::SetTriggers (TriggerCollection *value)
{
	SetValue (UIElement::TriggersProperty, Value (value));
}

ResourceDictionary *
UIElement::GetResources ()
{
	Value *value = GetValue (UIElement::ResourcesProperty);
	return value ? value->AsResourceDictionary () : NULL;
}

void
UIElement::SetResources (ResourceDictionary *value)
{
	SetValue (UIElement::ResourcesProperty, Value (value));
}

Transform *
UIElement::GetRenderTransform ()
{
	Value *value = GetValue (UIElement::RenderTransformProperty);
	return value ? value->AsTransform () : NULL;
}

void
UIElement::SetRenderTransform (Transform *value)
{
	SetValue (UIElement::RenderTransformProperty, Value (value));
}

Point *
UIElement::GetRenderTransformOrigin ()
{
	Value *value = GetValue (UIElement::RenderTransformOriginProperty);
	return value ? value->AsPoint () : NULL;
}

void
UIElement::SetRenderTransformOrigin (Point *value)
{
	if (!value) return;
	SetValue (UIElement::RenderTransformOriginProperty, Value (*value));
}

double
UIElement::GetOpacity ()
{
	Value *value = GetValue (UIElement::OpacityProperty);
	return value->AsDouble ();
}

void
UIElement::SetOpacity (double value)
{
	SetValue (UIElement::OpacityProperty, Value (value));
}

Brush *
UIElement::GetOpacityMask ()
{
	Value *value = GetValue (UIElement::OpacityMaskProperty);
	return value ? value->AsBrush () : NULL;
}

void
UIElement::SetOpacityMask (Brush *value)
{
	SetValue (UIElement::OpacityMaskProperty, Value (value));
}

bool
UIElement::GetIsHitTestVisible ()
{
	Value *value = GetValue (UIElement::IsHitTestVisibleProperty);
	return value->AsBool ();
}

void
UIElement::SetIsHitTestVisible (bool value)
{
	SetValue (UIElement::IsHitTestVisibleProperty, Value (value));
}

MouseCursor
UIElement::GetCursor ()
{
	Value *value = GetValue (UIElement::CursorProperty);
	return (MouseCursor) value->AsInt32 ();
}

void
UIElement::SetCursor (MouseCursor value)
{
	SetValue (UIElement::CursorProperty, Value (value));
}

Geometry *
UIElement::GetClip ()
{
	Value *value = GetValue (UIElement::ClipProperty);
	return value ? value->AsGeometry () : NULL;
}

void
UIElement::SetClip (Geometry *value)
{
	SetValue (UIElement::ClipProperty, Value (value));
}

EasingMode
EasingFunctionBase::GetEasingMode ()
{
	Value *value = GetValue (EasingFunctionBase::EasingModeProperty);
	return (EasingMode) value->AsInt32 ();
}

void
EasingFunctionBase::SetEasingMode (EasingMode value)
{
	SetValue (EasingFunctionBase::EasingModeProperty, Value (value));
}

ResourceDictionary *
Application::GetResources ()
{
	Value *value = GetValue (Application::ResourcesProperty);
	return value ? value->AsResourceDictionary () : NULL;
}

void
Application::SetResources (ResourceDictionary *value)
{
	SetValue (Application::ResourcesProperty, Value (value));
}

KeySpline *
SplineColorKeyFrame::GetKeySpline ()
{
	Value *value = DependencyObject::GetValue (SplineColorKeyFrame::KeySplineProperty);
	return value ? value->AsKeySpline () : NULL;
}

void
SplineColorKeyFrame::SetKeySpline (KeySpline *value)
{
	DependencyObject::SetValue (SplineColorKeyFrame::KeySplineProperty, Value (value));
}

EasingFunctionBase *
EasingColorKeyFrame::GetEasingFunction ()
{
	Value *value = DependencyObject::GetValue (EasingColorKeyFrame::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
EasingColorKeyFrame::SetEasingFunction (EasingFunctionBase *value)
{
	DependencyObject::SetValue (EasingColorKeyFrame::EasingFunctionProperty, Value (value));
}

ColorKeyFrameCollection *
ColorAnimationUsingKeyFrames::GetKeyFrames ()
{
	Value *value = GetValue (ColorAnimationUsingKeyFrames::KeyFramesProperty);
	return value ? value->AsColorKeyFrameCollection () : NULL;
}

void
ColorAnimationUsingKeyFrames::SetKeyFrames (ColorKeyFrameCollection *value)
{
	SetValue (ColorAnimationUsingKeyFrames::KeyFramesProperty, Value (value));
}

Uri *
BitmapImage::GetUriSource ()
{
	Value *value = GetValue (BitmapImage::UriSourceProperty);
	return value ? value->AsUri () : NULL;
}

void
BitmapImage::SetUriSource (Uri *value)
{
	if (!value) return;
	SetValue (BitmapImage::UriSourceProperty, Value (*value));
}

double
BitmapImage::GetProgress ()
{
	Value *value = GetValue (BitmapImage::ProgressProperty);
	return value->AsDouble ();
}

void
BitmapImage::SetProgress (double value)
{
	SetValue (BitmapImage::ProgressProperty, Value (value));
}

double
TranslateTransform::GetY ()
{
	Value *value = GetValue (TranslateTransform::YProperty);
	return value->AsDouble ();
}

void
TranslateTransform::SetY (double value)
{
	SetValue (TranslateTransform::YProperty, Value (value));
}

double
TranslateTransform::GetX ()
{
	Value *value = GetValue (TranslateTransform::XProperty);
	return value->AsDouble ();
}

void
TranslateTransform::SetX (double value)
{
	SetValue (TranslateTransform::XProperty, Value (value));
}

TransformCollection *
TransformGroup::GetChildren ()
{
	Value *value = GetValue (TransformGroup::ChildrenProperty);
	return value ? value->AsTransformCollection () : NULL;
}

void
TransformGroup::SetChildren (TransformCollection *value)
{
	SetValue (TransformGroup::ChildrenProperty, Value (value));
}

ScrollBarVisibility
TextBox::GetVerticalScrollBarVisibility ()
{
	Value *value = GetValue (TextBox::VerticalScrollBarVisibilityProperty);
	return (ScrollBarVisibility) value->AsInt32 ();
}

void
TextBox::SetVerticalScrollBarVisibility (ScrollBarVisibility value)
{
	SetValue (TextBox::VerticalScrollBarVisibilityProperty, Value (value));
}

TextWrapping
TextBox::GetTextWrapping ()
{
	Value *value = GetValue (TextBox::TextWrappingProperty);
	return (TextWrapping) value->AsInt32 ();
}

void
TextBox::SetTextWrapping (TextWrapping value)
{
	SetValue (TextBox::TextWrappingProperty, Value (value));
}

const char *
TextBox::GetText ()
{
	Value *value = GetValue (TextBox::TextProperty);
	return value ? value->AsString () : NULL;
}

void
TextBox::SetText (const char *value)
{
	SetValue (TextBox::TextProperty, Value (value));
}

TextAlignment
TextBox::GetTextAlignment ()
{
	Value *value = GetValue (TextBox::TextAlignmentProperty);
	return (TextAlignment) value->AsInt32 ();
}

void
TextBox::SetTextAlignment (TextAlignment value)
{
	SetValue (TextBox::TextAlignmentProperty, Value (value));
}

gint32
TextBox::GetSelectionStart ()
{
	Value *value = GetValue (TextBox::SelectionStartProperty);
	return value->AsInt32 ();
}

void
TextBox::SetSelectionStart (gint32 value)
{
	SetValue (TextBox::SelectionStartProperty, Value (value));
}

gint32
TextBox::GetSelectionLength ()
{
	Value *value = GetValue (TextBox::SelectionLengthProperty);
	return value->AsInt32 ();
}

void
TextBox::SetSelectionLength (gint32 value)
{
	SetValue (TextBox::SelectionLengthProperty, Value (value));
}

Brush *
TextBox::GetSelectionForeground ()
{
	Value *value = GetValue (TextBox::SelectionForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
TextBox::SetSelectionForeground (Brush *value)
{
	SetValue (TextBox::SelectionForegroundProperty, Value (value));
}

Brush *
TextBox::GetSelectionBackground ()
{
	Value *value = GetValue (TextBox::SelectionBackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
TextBox::SetSelectionBackground (Brush *value)
{
	SetValue (TextBox::SelectionBackgroundProperty, Value (value));
}

const char *
TextBox::GetSelectedText ()
{
	Value *value = GetValue (TextBox::SelectedTextProperty);
	return value ? value->AsString () : NULL;
}

void
TextBox::SetSelectedText (const char *value)
{
	SetValue (TextBox::SelectedTextProperty, Value (value));
}

gint32
TextBox::GetMaxLength ()
{
	Value *value = GetValue (TextBox::MaxLengthProperty);
	return value->AsInt32 ();
}

void
TextBox::SetMaxLength (gint32 value)
{
	SetValue (TextBox::MaxLengthProperty, Value (value));
}

bool
TextBox::GetIsReadOnly ()
{
	Value *value = GetValue (TextBox::IsReadOnlyProperty);
	return value->AsBool ();
}

void
TextBox::SetIsReadOnly (bool value)
{
	SetValue (TextBox::IsReadOnlyProperty, Value (value));
}

ScrollBarVisibility
TextBox::GetHorizontalScrollBarVisibility ()
{
	Value *value = GetValue (TextBox::HorizontalScrollBarVisibilityProperty);
	return (ScrollBarVisibility) value->AsInt32 ();
}

void
TextBox::SetHorizontalScrollBarVisibility (ScrollBarVisibility value)
{
	SetValue (TextBox::HorizontalScrollBarVisibilityProperty, Value (value));
}

FontSource *
TextBox::GetFontSource ()
{
	Value *value = GetValue (TextBox::FontSourceProperty);
	return value ? value->AsFontSource () : NULL;
}

void
TextBox::SetFontSource (FontSource *value)
{
	if (!value) return;
	SetValue (TextBox::FontSourceProperty, Value (*value));
}

bool
TextBox::GetAcceptsReturn ()
{
	Value *value = GetValue (TextBox::AcceptsReturnProperty);
	return value->AsBool ();
}

void
TextBox::SetAcceptsReturn (bool value)
{
	SetValue (TextBox::AcceptsReturnProperty, Value (value));
}

PropertyPath *
Storyboard::GetTargetProperty (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Storyboard::TargetPropertyProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Storyboard::TargetPropertyProperty)->GetDefaultValue();
	return value ? value->AsPropertyPath () : NULL;
}

void
Storyboard::SetTargetProperty (DependencyObject *obj, PropertyPath *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (Storyboard::TargetPropertyProperty, Value (*value));
}

const char *
Storyboard::GetTargetName (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (Storyboard::TargetNameProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (Storyboard::TargetNameProperty)->GetDefaultValue();
	return value ? value->AsString () : NULL;
}

void
Storyboard::SetTargetName (DependencyObject *obj, const char *value)
{
	if (!obj) return;
	obj->SetValue (Storyboard::TargetNameProperty, Value (value));
}

double
SkewTransform::GetCenterY ()
{
	Value *value = GetValue (SkewTransform::CenterYProperty);
	return value->AsDouble ();
}

void
SkewTransform::SetCenterY (double value)
{
	SetValue (SkewTransform::CenterYProperty, Value (value));
}

double
SkewTransform::GetCenterX ()
{
	Value *value = GetValue (SkewTransform::CenterXProperty);
	return value->AsDouble ();
}

void
SkewTransform::SetCenterX (double value)
{
	SetValue (SkewTransform::CenterXProperty, Value (value));
}

double
SkewTransform::GetAngleY ()
{
	Value *value = GetValue (SkewTransform::AngleYProperty);
	return value->AsDouble ();
}

void
SkewTransform::SetAngleY (double value)
{
	SetValue (SkewTransform::AngleYProperty, Value (value));
}

double
SkewTransform::GetAngleX ()
{
	Value *value = GetValue (SkewTransform::AngleXProperty);
	return value->AsDouble ();
}

void
SkewTransform::SetAngleX (double value)
{
	SetValue (SkewTransform::AngleXProperty, Value (value));
}

bool
SetterBaseCollection::GetIsSealed ()
{
	Value *value = GetValue (SetterBaseCollection::IsSealedProperty);
	return value->AsBool ();
}

void
SetterBaseCollection::SetIsSealed (bool value)
{
	SetValue (SetterBaseCollection::IsSealedProperty, Value (value));
}

double
ScaleTransform::GetScaleY ()
{
	Value *value = GetValue (ScaleTransform::ScaleYProperty);
	return value->AsDouble ();
}

void
ScaleTransform::SetScaleY (double value)
{
	SetValue (ScaleTransform::ScaleYProperty, Value (value));
}

double
ScaleTransform::GetScaleX ()
{
	Value *value = GetValue (ScaleTransform::ScaleXProperty);
	return value->AsDouble ();
}

void
ScaleTransform::SetScaleX (double value)
{
	SetValue (ScaleTransform::ScaleXProperty, Value (value));
}

double
ScaleTransform::GetCenterY ()
{
	Value *value = GetValue (ScaleTransform::CenterYProperty);
	return value->AsDouble ();
}

void
ScaleTransform::SetCenterY (double value)
{
	SetValue (ScaleTransform::CenterYProperty, Value (value));
}

double
ScaleTransform::GetCenterX ()
{
	Value *value = GetValue (ScaleTransform::CenterXProperty);
	return value->AsDouble ();
}

void
ScaleTransform::SetCenterX (double value)
{
	SetValue (ScaleTransform::CenterXProperty, Value (value));
}

double
RotateTransform::GetCenterY ()
{
	Value *value = GetValue (RotateTransform::CenterYProperty);
	return value->AsDouble ();
}

void
RotateTransform::SetCenterY (double value)
{
	SetValue (RotateTransform::CenterYProperty, Value (value));
}

double
RotateTransform::GetCenterX ()
{
	Value *value = GetValue (RotateTransform::CenterXProperty);
	return value->AsDouble ();
}

void
RotateTransform::SetCenterX (double value)
{
	SetValue (RotateTransform::CenterXProperty, Value (value));
}

double
RotateTransform::GetAngle ()
{
	Value *value = GetValue (RotateTransform::AngleProperty);
	return value->AsDouble ();
}

void
RotateTransform::SetAngle (double value)
{
	SetValue (RotateTransform::AngleProperty, Value (value));
}

Point *
QuadraticBezierSegment::GetPoint2 ()
{
	Value *value = GetValue (QuadraticBezierSegment::Point2Property);
	return value ? value->AsPoint () : NULL;
}

void
QuadraticBezierSegment::SetPoint2 (Point *value)
{
	if (!value) return;
	SetValue (QuadraticBezierSegment::Point2Property, Value (*value));
}

Point *
QuadraticBezierSegment::GetPoint1 ()
{
	Value *value = GetValue (QuadraticBezierSegment::Point1Property);
	return value ? value->AsPoint () : NULL;
}

void
QuadraticBezierSegment::SetPoint1 (Point *value)
{
	if (!value) return;
	SetValue (QuadraticBezierSegment::Point1Property, Value (*value));
}

PointCollection *
PolyQuadraticBezierSegment::GetPoints ()
{
	Value *value = GetValue (PolyQuadraticBezierSegment::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
PolyQuadraticBezierSegment::SetPoints (PointCollection *value)
{
	SetValue (PolyQuadraticBezierSegment::PointsProperty, Value (value));
}

PointCollection *
PolyLineSegment::GetPoints ()
{
	Value *value = GetValue (PolyLineSegment::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
PolyLineSegment::SetPoints (PointCollection *value)
{
	SetValue (PolyLineSegment::PointsProperty, Value (value));
}

PointCollection *
PolyBezierSegment::GetPoints ()
{
	Value *value = GetValue (PolyBezierSegment::PointsProperty);
	return value ? value->AsPointCollection () : NULL;
}

void
PolyBezierSegment::SetPoints (PointCollection *value)
{
	SetValue (PolyBezierSegment::PointsProperty, Value (value));
}

Point *
PointKeyFrame::GetValue ()
{
	Value *value = DependencyObject::GetValue (PointKeyFrame::ValueProperty);
	return value ? value->AsPoint () : NULL;
}

void
PointKeyFrame::SetValue (Point value)
{
	DependencyObject::SetValue (PointKeyFrame::ValueProperty, Value (value));
}

void
PointKeyFrame::SetValue (Point *value)
{
	if (!value)
		DependencyObject::SetValue (PointKeyFrame::ValueProperty, NULL);
	else
		DependencyObject::SetValue (PointKeyFrame::ValueProperty, Value (*value));
}

KeyTime *
PointKeyFrame::GetKeyTime ()
{
	Value *value = DependencyObject::GetValue (PointKeyFrame::KeyTimeProperty);
	return value ? value->AsKeyTime () : NULL;
}

void
PointKeyFrame::SetKeyTime (KeyTime value)
{
	DependencyObject::SetValue (PointKeyFrame::KeyTimeProperty, Value (value));
}

void
PointKeyFrame::SetKeyTime (KeyTime *value)
{
	if (!value)
		DependencyObject::SetValue (PointKeyFrame::KeyTimeProperty, NULL);
	else
		DependencyObject::SetValue (PointKeyFrame::KeyTimeProperty, Value (*value));
}

Point *
PointAnimation::GetTo ()
{
	Value *value = GetValue (PointAnimation::ToProperty);
	return value ? value->AsPoint () : NULL;
}

void
PointAnimation::SetTo (Point value)
{
	SetValue (PointAnimation::ToProperty, Value (value));
}

void
PointAnimation::SetTo (Point *value)
{
	if (!value)
		SetValue (PointAnimation::ToProperty, NULL);
	else
		SetValue (PointAnimation::ToProperty, Value (*value));
}

Point *
PointAnimation::GetFrom ()
{
	Value *value = GetValue (PointAnimation::FromProperty);
	return value ? value->AsPoint () : NULL;
}

void
PointAnimation::SetFrom (Point value)
{
	SetValue (PointAnimation::FromProperty, Value (value));
}

void
PointAnimation::SetFrom (Point *value)
{
	if (!value)
		SetValue (PointAnimation::FromProperty, NULL);
	else
		SetValue (PointAnimation::FromProperty, Value (*value));
}

EasingFunctionBase *
PointAnimation::GetEasingFunction ()
{
	Value *value = GetValue (PointAnimation::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
PointAnimation::SetEasingFunction (EasingFunctionBase *value)
{
	SetValue (PointAnimation::EasingFunctionProperty, Value (value));
}

Point *
PointAnimation::GetBy ()
{
	Value *value = GetValue (PointAnimation::ByProperty);
	return value ? value->AsPoint () : NULL;
}

void
PointAnimation::SetBy (Point value)
{
	SetValue (PointAnimation::ByProperty, Value (value));
}

void
PointAnimation::SetBy (Point *value)
{
	if (!value)
		SetValue (PointAnimation::ByProperty, NULL);
	else
		SetValue (PointAnimation::ByProperty, Value (*value));
}

gint32
PasswordBox::GetSelectionStart ()
{
	Value *value = GetValue (PasswordBox::SelectionStartProperty);
	return value->AsInt32 ();
}

void
PasswordBox::SetSelectionStart (gint32 value)
{
	SetValue (PasswordBox::SelectionStartProperty, Value (value));
}

gint32
PasswordBox::GetSelectionLength ()
{
	Value *value = GetValue (PasswordBox::SelectionLengthProperty);
	return value->AsInt32 ();
}

void
PasswordBox::SetSelectionLength (gint32 value)
{
	SetValue (PasswordBox::SelectionLengthProperty, Value (value));
}

Brush *
PasswordBox::GetSelectionForeground ()
{
	Value *value = GetValue (PasswordBox::SelectionForegroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
PasswordBox::SetSelectionForeground (Brush *value)
{
	SetValue (PasswordBox::SelectionForegroundProperty, Value (value));
}

Brush *
PasswordBox::GetSelectionBackground ()
{
	Value *value = GetValue (PasswordBox::SelectionBackgroundProperty);
	return value ? value->AsBrush () : NULL;
}

void
PasswordBox::SetSelectionBackground (Brush *value)
{
	SetValue (PasswordBox::SelectionBackgroundProperty, Value (value));
}

const char *
PasswordBox::GetSelectedText ()
{
	Value *value = GetValue (PasswordBox::SelectedTextProperty);
	return value ? value->AsString () : NULL;
}

void
PasswordBox::SetSelectedText (const char *value)
{
	SetValue (PasswordBox::SelectedTextProperty, Value (value));
}

const char *
PasswordBox::GetPassword ()
{
	Value *value = GetValue (PasswordBox::PasswordProperty);
	return value ? value->AsString () : NULL;
}

void
PasswordBox::SetPassword (const char *value)
{
	SetValue (PasswordBox::PasswordProperty, Value (value));
}

gint32
PasswordBox::GetPasswordChar ()
{
	Value *value = GetValue (PasswordBox::PasswordCharProperty);
	return value->AsInt32 ();
}

void
PasswordBox::SetPasswordChar (gint32 value)
{
	SetValue (PasswordBox::PasswordCharProperty, Value (value));
}

gint32
PasswordBox::GetMaxLength ()
{
	Value *value = GetValue (PasswordBox::MaxLengthProperty);
	return value->AsInt32 ();
}

void
PasswordBox::SetMaxLength (gint32 value)
{
	SetValue (PasswordBox::MaxLengthProperty, Value (value));
}

FontSource *
PasswordBox::GetFontSource ()
{
	Value *value = GetValue (PasswordBox::FontSourceProperty);
	return value ? value->AsFontSource () : NULL;
}

void
PasswordBox::SetFontSource (FontSource *value)
{
	if (!value) return;
	SetValue (PasswordBox::FontSourceProperty, Value (*value));
}

KeyTime *
ObjectKeyFrame::GetKeyTime ()
{
	Value *value = DependencyObject::GetValue (ObjectKeyFrame::KeyTimeProperty);
	return value ? value->AsKeyTime () : NULL;
}

void
ObjectKeyFrame::SetKeyTime (KeyTime value)
{
	DependencyObject::SetValue (ObjectKeyFrame::KeyTimeProperty, Value (value));
}

void
ObjectKeyFrame::SetKeyTime (KeyTime *value)
{
	if (!value)
		DependencyObject::SetValue (ObjectKeyFrame::KeyTimeProperty, NULL);
	else
		DependencyObject::SetValue (ObjectKeyFrame::KeyTimeProperty, Value (*value));
}

ObjectKeyFrameCollection *
ObjectAnimationUsingKeyFrames::GetKeyFrames ()
{
	Value *value = GetValue (ObjectAnimationUsingKeyFrames::KeyFramesProperty);
	return value ? value->AsObjectKeyFrameCollection () : NULL;
}

void
ObjectAnimationUsingKeyFrames::SetKeyFrames (ObjectKeyFrameCollection *value)
{
	SetValue (ObjectAnimationUsingKeyFrames::KeyFramesProperty, Value (value));
}

Matrix *
MatrixTransform::GetMatrix ()
{
	Value *value = GetValue (MatrixTransform::MatrixProperty);
	return value ? value->AsMatrix () : NULL;
}

void
MatrixTransform::SetMatrix (Matrix *value)
{
	SetValue (MatrixTransform::MatrixProperty, Value (value));
}

Point *
LineSegment::GetPoint ()
{
	Value *value = GetValue (LineSegment::PointProperty);
	return value ? value->AsPoint () : NULL;
}

void
LineSegment::SetPoint (Point *value)
{
	if (!value) return;
	SetValue (LineSegment::PointProperty, Value (*value));
}

Rect *
LayoutInformation::GetLayoutSlot (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LayoutSlotProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LayoutSlotProperty)->GetDefaultValue();
	return value ? value->AsRect () : NULL;
}

void
LayoutInformation::SetLayoutSlot (DependencyObject *obj, Rect *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (LayoutInformation::LayoutSlotProperty, Value (*value));
}

Geometry *
LayoutInformation::GetLayoutClip (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LayoutClipProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LayoutClipProperty)->GetDefaultValue();
	return value ? value->AsGeometry () : NULL;
}

void
LayoutInformation::SetLayoutClip (DependencyObject *obj, Geometry *value)
{
	if (!obj) return;
	obj->SetValue (LayoutInformation::LayoutClipProperty, Value (value));
}

Size *
LayoutInformation::GetLastRenderSize (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LastRenderSizeProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LastRenderSizeProperty)->GetDefaultValue();
	return value ? value->AsSize () : NULL;
}

void
LayoutInformation::SetLastRenderSize (DependencyObject *obj, Size *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (LayoutInformation::LastRenderSizeProperty, Value (*value));
}

Size *
LayoutInformation::GetLastMeasure (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LastMeasureProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LastMeasureProperty)->GetDefaultValue();
	return value ? value->AsSize () : NULL;
}

void
LayoutInformation::SetLastMeasure (DependencyObject *obj, Size *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (LayoutInformation::LastMeasureProperty, Value (*value));
}

Size *
LayoutInformation::GetLastArrange (DependencyObject *obj)
{
	Value *value = (!obj) ? NULL : obj->GetValue (LayoutInformation::LastArrangeProperty);
	if (!value) value = Deployment::GetCurrent ()->GetTypes ()->GetProperty (LayoutInformation::LastArrangeProperty)->GetDefaultValue();
	return value ? value->AsSize () : NULL;
}

void
LayoutInformation::SetLastArrange (DependencyObject *obj, Size *value)
{
	if (!obj) return;
	if (!value) return;
	obj->SetValue (LayoutInformation::LastArrangeProperty, Value (*value));
}

const char *
EventTrigger::GetRoutedEvent ()
{
	Value *value = GetValue (EventTrigger::RoutedEventProperty);
	return value ? value->AsString () : NULL;
}

void
EventTrigger::SetRoutedEvent (const char *value)
{
	SetValue (EventTrigger::RoutedEventProperty, Value (value));
}

TriggerActionCollection *
EventTrigger::GetActions ()
{
	Value *value = GetValue (EventTrigger::ActionsProperty);
	return value ? value->AsTriggerActionCollection () : NULL;
}

void
EventTrigger::SetActions (TriggerActionCollection *value)
{
	SetValue (EventTrigger::ActionsProperty, Value (value));
}

double *
DoubleKeyFrame::GetValue ()
{
	Value *value = DependencyObject::GetValue (DoubleKeyFrame::ValueProperty);
	return value ? value->AsNullableDouble () : NULL;
}

void
DoubleKeyFrame::SetValue (double value)
{
	DependencyObject::SetValue (DoubleKeyFrame::ValueProperty, Value (value));
}

void
DoubleKeyFrame::SetValue (double * value)
{
	if (!value)
		DependencyObject::SetValue (DoubleKeyFrame::ValueProperty, NULL);
	else
		DependencyObject::SetValue (DoubleKeyFrame::ValueProperty, Value (*value));
}

KeyTime *
DoubleKeyFrame::GetKeyTime ()
{
	Value *value = DependencyObject::GetValue (DoubleKeyFrame::KeyTimeProperty);
	return value ? value->AsKeyTime () : NULL;
}

void
DoubleKeyFrame::SetKeyTime (KeyTime value)
{
	DependencyObject::SetValue (DoubleKeyFrame::KeyTimeProperty, Value (value));
}

void
DoubleKeyFrame::SetKeyTime (KeyTime *value)
{
	if (!value)
		DependencyObject::SetValue (DoubleKeyFrame::KeyTimeProperty, NULL);
	else
		DependencyObject::SetValue (DoubleKeyFrame::KeyTimeProperty, Value (*value));
}

double *
DoubleAnimation::GetTo ()
{
	Value *value = GetValue (DoubleAnimation::ToProperty);
	return value ? value->AsNullableDouble () : NULL;
}

void
DoubleAnimation::SetTo (double value)
{
	SetValue (DoubleAnimation::ToProperty, Value (value));
}

void
DoubleAnimation::SetTo (double * value)
{
	if (!value)
		SetValue (DoubleAnimation::ToProperty, NULL);
	else
		SetValue (DoubleAnimation::ToProperty, Value (*value));
}

double *
DoubleAnimation::GetFrom ()
{
	Value *value = GetValue (DoubleAnimation::FromProperty);
	return value ? value->AsNullableDouble () : NULL;
}

void
DoubleAnimation::SetFrom (double value)
{
	SetValue (DoubleAnimation::FromProperty, Value (value));
}

void
DoubleAnimation::SetFrom (double * value)
{
	if (!value)
		SetValue (DoubleAnimation::FromProperty, NULL);
	else
		SetValue (DoubleAnimation::FromProperty, Value (*value));
}

EasingFunctionBase *
DoubleAnimation::GetEasingFunction ()
{
	Value *value = GetValue (DoubleAnimation::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
DoubleAnimation::SetEasingFunction (EasingFunctionBase *value)
{
	SetValue (DoubleAnimation::EasingFunctionProperty, Value (value));
}

double *
DoubleAnimation::GetBy ()
{
	Value *value = GetValue (DoubleAnimation::ByProperty);
	return value ? value->AsNullableDouble () : NULL;
}

void
DoubleAnimation::SetBy (double value)
{
	SetValue (DoubleAnimation::ByProperty, Value (value));
}

void
DoubleAnimation::SetBy (double * value)
{
	if (!value)
		SetValue (DoubleAnimation::ByProperty, NULL);
	else
		SetValue (DoubleAnimation::ByProperty, Value (*value));
}

const char *
DependencyObject::GetName ()
{
	Value *value = GetValue (DependencyObject::NameProperty);
	return value ? value->AsString () : NULL;
}

void
DependencyObject::SetName (const char *value)
{
	SetValue (DependencyObject::NameProperty, Value (value));
}

Uri *
DeepZoomImageTileSource::GetUriSource ()
{
	Value *value = GetValue (DeepZoomImageTileSource::UriSourceProperty);
	return value ? value->AsUri () : NULL;
}

void
DeepZoomImageTileSource::SetUriSource (Uri *value)
{
	if (!value) return;
	SetValue (DeepZoomImageTileSource::UriSourceProperty, Value (*value));
}

Color *
ColorKeyFrame::GetValue ()
{
	Value *value = DependencyObject::GetValue (ColorKeyFrame::ValueProperty);
	return value ? value->AsColor () : NULL;
}

void
ColorKeyFrame::SetValue (Color value)
{
	DependencyObject::SetValue (ColorKeyFrame::ValueProperty, Value (value));
}

void
ColorKeyFrame::SetValue (Color *value)
{
	if (!value)
		DependencyObject::SetValue (ColorKeyFrame::ValueProperty, NULL);
	else
		DependencyObject::SetValue (ColorKeyFrame::ValueProperty, Value (*value));
}

KeyTime *
ColorKeyFrame::GetKeyTime ()
{
	Value *value = DependencyObject::GetValue (ColorKeyFrame::KeyTimeProperty);
	return value ? value->AsKeyTime () : NULL;
}

void
ColorKeyFrame::SetKeyTime (KeyTime value)
{
	DependencyObject::SetValue (ColorKeyFrame::KeyTimeProperty, Value (value));
}

void
ColorKeyFrame::SetKeyTime (KeyTime *value)
{
	if (!value)
		DependencyObject::SetValue (ColorKeyFrame::KeyTimeProperty, NULL);
	else
		DependencyObject::SetValue (ColorKeyFrame::KeyTimeProperty, Value (*value));
}

Color *
ColorAnimation::GetTo ()
{
	Value *value = GetValue (ColorAnimation::ToProperty);
	return value ? value->AsColor () : NULL;
}

void
ColorAnimation::SetTo (Color value)
{
	SetValue (ColorAnimation::ToProperty, Value (value));
}

void
ColorAnimation::SetTo (Color *value)
{
	if (!value)
		SetValue (ColorAnimation::ToProperty, NULL);
	else
		SetValue (ColorAnimation::ToProperty, Value (*value));
}

Color *
ColorAnimation::GetFrom ()
{
	Value *value = GetValue (ColorAnimation::FromProperty);
	return value ? value->AsColor () : NULL;
}

void
ColorAnimation::SetFrom (Color value)
{
	SetValue (ColorAnimation::FromProperty, Value (value));
}

void
ColorAnimation::SetFrom (Color *value)
{
	if (!value)
		SetValue (ColorAnimation::FromProperty, NULL);
	else
		SetValue (ColorAnimation::FromProperty, Value (*value));
}

EasingFunctionBase *
ColorAnimation::GetEasingFunction ()
{
	Value *value = GetValue (ColorAnimation::EasingFunctionProperty);
	return value ? value->AsEasingFunctionBase () : NULL;
}

void
ColorAnimation::SetEasingFunction (EasingFunctionBase *value)
{
	SetValue (ColorAnimation::EasingFunctionProperty, Value (value));
}

Color *
ColorAnimation::GetBy ()
{
	Value *value = GetValue (ColorAnimation::ByProperty);
	return value ? value->AsColor () : NULL;
}

void
ColorAnimation::SetBy (Color value)
{
	SetValue (ColorAnimation::ByProperty, Value (value));
}

void
ColorAnimation::SetBy (Color *value)
{
	if (!value)
		SetValue (ColorAnimation::ByProperty, NULL);
	else
		SetValue (ColorAnimation::ByProperty, Value (*value));
}

gint32
BitmapSource::GetPixelWidth ()
{
	Value *value = GetValue (BitmapSource::PixelWidthProperty);
	return value->AsInt32 ();
}

void
BitmapSource::SetPixelWidth (gint32 value)
{
	SetValue (BitmapSource::PixelWidthProperty, Value (value));
}

gint32
BitmapSource::GetPixelHeight ()
{
	Value *value = GetValue (BitmapSource::PixelHeightProperty);
	return value->AsInt32 ();
}

void
BitmapSource::SetPixelHeight (gint32 value)
{
	SetValue (BitmapSource::PixelHeightProperty, Value (value));
}

PixelFormats
BitmapSource::GetPixelFormat ()
{
	Value *value = GetValue (BitmapSource::PixelFormatProperty);
	return (PixelFormats) value->AsInt32 ();
}

void
BitmapSource::SetPixelFormat (PixelFormats value)
{
	SetValue (BitmapSource::PixelFormatProperty, Value (value));
}

Point *
BezierSegment::GetPoint3 ()
{
	Value *value = GetValue (BezierSegment::Point3Property);
	return value ? value->AsPoint () : NULL;
}

void
BezierSegment::SetPoint3 (Point *value)
{
	if (!value) return;
	SetValue (BezierSegment::Point3Property, Value (*value));
}

Point *
BezierSegment::GetPoint2 ()
{
	Value *value = GetValue (BezierSegment::Point2Property);
	return value ? value->AsPoint () : NULL;
}

void
BezierSegment::SetPoint2 (Point *value)
{
	if (!value) return;
	SetValue (BezierSegment::Point2Property, Value (*value));
}

Point *
BezierSegment::GetPoint1 ()
{
	Value *value = GetValue (BezierSegment::Point1Property);
	return value ? value->AsPoint () : NULL;
}

void
BezierSegment::SetPoint1 (Point *value)
{
	if (!value) return;
	SetValue (BezierSegment::Point1Property, Value (*value));
}

Storyboard *
BeginStoryboard::GetStoryboard ()
{
	Value *value = GetValue (BeginStoryboard::StoryboardProperty);
	return value ? value->AsStoryboard () : NULL;
}

void
BeginStoryboard::SetStoryboard (Storyboard *value)
{
	SetValue (BeginStoryboard::StoryboardProperty, Value (value));
}

SweepDirection
ArcSegment::GetSweepDirection ()
{
	Value *value = GetValue (ArcSegment::SweepDirectionProperty);
	return (SweepDirection) value->AsInt32 ();
}

void
ArcSegment::SetSweepDirection (SweepDirection value)
{
	SetValue (ArcSegment::SweepDirectionProperty, Value (value));
}

Size *
ArcSegment::GetSize ()
{
	Value *value = GetValue (ArcSegment::SizeProperty);
	return value ? value->AsSize () : NULL;
}

void
ArcSegment::SetSize (Size *value)
{
	if (!value) return;
	SetValue (ArcSegment::SizeProperty, Value (*value));
}

double
ArcSegment::GetRotationAngle ()
{
	Value *value = GetValue (ArcSegment::RotationAngleProperty);
	return value->AsDouble ();
}

void
ArcSegment::SetRotationAngle (double value)
{
	SetValue (ArcSegment::RotationAngleProperty, Value (value));
}

Point *
ArcSegment::GetPoint ()
{
	Value *value = GetValue (ArcSegment::PointProperty);
	return value ? value->AsPoint () : NULL;
}

void
ArcSegment::SetPoint (Point *value)
{
	if (!value) return;
	SetValue (ArcSegment::PointProperty, Value (*value));
}

bool
ArcSegment::GetIsLargeArc ()
{
	Value *value = GetValue (ArcSegment::IsLargeArcProperty);
	return value->AsBool ();
}

void
ArcSegment::SetIsLargeArc (bool value)
{
	SetValue (ArcSegment::IsLargeArcProperty, Value (value));
}

